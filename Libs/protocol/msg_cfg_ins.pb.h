// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_cfg_ins.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_5fcfg_5fins_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_5fcfg_5fins_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_5fcfg_5fins_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_5fcfg_5fins_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_5fcfg_5fins_2eproto;
namespace packet {
class Grid_BlockArea;
struct Grid_BlockAreaDefaultTypeInternal;
extern Grid_BlockAreaDefaultTypeInternal _Grid_BlockArea_default_instance_;
class Grid_MonsterGroup;
struct Grid_MonsterGroupDefaultTypeInternal;
extern Grid_MonsterGroupDefaultTypeInternal _Grid_MonsterGroup_default_instance_;
class Grid_MonsterGroup_Grid_MonsterGroupUnit;
struct Grid_MonsterGroup_Grid_MonsterGroupUnitDefaultTypeInternal;
extern Grid_MonsterGroup_Grid_MonsterGroupUnitDefaultTypeInternal _Grid_MonsterGroup_Grid_MonsterGroupUnit_default_instance_;
class Grid_Point;
struct Grid_PointDefaultTypeInternal;
extern Grid_PointDefaultTypeInternal _Grid_Point_default_instance_;
class Grid_Rect;
struct Grid_RectDefaultTypeInternal;
extern Grid_RectDefaultTypeInternal _Grid_Rect_default_instance_;
class Grid_RigNPC;
struct Grid_RigNPCDefaultTypeInternal;
extern Grid_RigNPCDefaultTypeInternal _Grid_RigNPC_default_instance_;
class Grid_Rotation;
struct Grid_RotationDefaultTypeInternal;
extern Grid_RotationDefaultTypeInternal _Grid_Rotation_default_instance_;
class Grid_Teleporter;
struct Grid_TeleporterDefaultTypeInternal;
extern Grid_TeleporterDefaultTypeInternal _Grid_Teleporter_default_instance_;
class Map_AllTypes;
struct Map_AllTypesDefaultTypeInternal;
extern Map_AllTypesDefaultTypeInternal _Map_AllTypes_default_instance_;
class Map_BlockArea;
struct Map_BlockAreaDefaultTypeInternal;
extern Map_BlockAreaDefaultTypeInternal _Map_BlockArea_default_instance_;
class Map_Info;
struct Map_InfoDefaultTypeInternal;
extern Map_InfoDefaultTypeInternal _Map_Info_default_instance_;
class Map_MonsterGroup;
struct Map_MonsterGroupDefaultTypeInternal;
extern Map_MonsterGroupDefaultTypeInternal _Map_MonsterGroup_default_instance_;
class Map_RigNPC;
struct Map_RigNPCDefaultTypeInternal;
extern Map_RigNPCDefaultTypeInternal _Map_RigNPC_default_instance_;
class Map_Teleporter;
struct Map_TeleporterDefaultTypeInternal;
extern Map_TeleporterDefaultTypeInternal _Map_Teleporter_default_instance_;
}  // namespace packet
PROTOBUF_NAMESPACE_OPEN
template<> ::packet::Grid_BlockArea* Arena::CreateMaybeMessage<::packet::Grid_BlockArea>(Arena*);
template<> ::packet::Grid_MonsterGroup* Arena::CreateMaybeMessage<::packet::Grid_MonsterGroup>(Arena*);
template<> ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* Arena::CreateMaybeMessage<::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit>(Arena*);
template<> ::packet::Grid_Point* Arena::CreateMaybeMessage<::packet::Grid_Point>(Arena*);
template<> ::packet::Grid_Rect* Arena::CreateMaybeMessage<::packet::Grid_Rect>(Arena*);
template<> ::packet::Grid_RigNPC* Arena::CreateMaybeMessage<::packet::Grid_RigNPC>(Arena*);
template<> ::packet::Grid_Rotation* Arena::CreateMaybeMessage<::packet::Grid_Rotation>(Arena*);
template<> ::packet::Grid_Teleporter* Arena::CreateMaybeMessage<::packet::Grid_Teleporter>(Arena*);
template<> ::packet::Map_AllTypes* Arena::CreateMaybeMessage<::packet::Map_AllTypes>(Arena*);
template<> ::packet::Map_BlockArea* Arena::CreateMaybeMessage<::packet::Map_BlockArea>(Arena*);
template<> ::packet::Map_Info* Arena::CreateMaybeMessage<::packet::Map_Info>(Arena*);
template<> ::packet::Map_MonsterGroup* Arena::CreateMaybeMessage<::packet::Map_MonsterGroup>(Arena*);
template<> ::packet::Map_RigNPC* Arena::CreateMaybeMessage<::packet::Map_RigNPC>(Arena*);
template<> ::packet::Map_Teleporter* Arena::CreateMaybeMessage<::packet::Map_Teleporter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace packet {

enum BrushType : int {
  BrushType_None = 0,
  BrushType_RigNPC = 1,
  BrushType_Teleporter = 2,
  BrushType_BlockArea = 3,
  BrushType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BrushType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BrushType_IsValid(int value);
constexpr BrushType BrushType_MIN = BrushType_None;
constexpr BrushType BrushType_MAX = BrushType_BlockArea;
constexpr int BrushType_ARRAYSIZE = BrushType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BrushType_descriptor();
template<typename T>
inline const std::string& BrushType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BrushType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BrushType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BrushType_descriptor(), enum_t_value);
}
inline bool BrushType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BrushType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BrushType>(
    BrushType_descriptor(), name, value);
}
// ===================================================================

class Grid_Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_Point) */ {
 public:
  inline Grid_Point() : Grid_Point(nullptr) {}
  ~Grid_Point() override;
  explicit PROTOBUF_CONSTEXPR Grid_Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_Point(const Grid_Point& from);
  Grid_Point(Grid_Point&& from) noexcept
    : Grid_Point() {
    *this = ::std::move(from);
  }

  inline Grid_Point& operator=(const Grid_Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_Point& operator=(Grid_Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_Point* internal_default_instance() {
    return reinterpret_cast<const Grid_Point*>(
               &_Grid_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Grid_Point& a, Grid_Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_Point& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_Point";
  }
  protected:
  explicit Grid_Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosXFieldNumber = 1,
    kPosYFieldNumber = 2,
  };
  // uint32 PosX = 1;
  void clear_posx();
  uint32_t posx() const;
  void set_posx(uint32_t value);
  private:
  uint32_t _internal_posx() const;
  void _internal_set_posx(uint32_t value);
  public:

  // uint32 PosY = 2;
  void clear_posy();
  uint32_t posy() const;
  void set_posy(uint32_t value);
  private:
  uint32_t _internal_posy() const;
  void _internal_set_posy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Grid_Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t posx_;
  uint32_t posy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Grid_Rotation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_Rotation) */ {
 public:
  inline Grid_Rotation() : Grid_Rotation(nullptr) {}
  ~Grid_Rotation() override;
  explicit PROTOBUF_CONSTEXPR Grid_Rotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_Rotation(const Grid_Rotation& from);
  Grid_Rotation(Grid_Rotation&& from) noexcept
    : Grid_Rotation() {
    *this = ::std::move(from);
  }

  inline Grid_Rotation& operator=(const Grid_Rotation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_Rotation& operator=(Grid_Rotation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_Rotation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_Rotation* internal_default_instance() {
    return reinterpret_cast<const Grid_Rotation*>(
               &_Grid_Rotation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Grid_Rotation& a, Grid_Rotation& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_Rotation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_Rotation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_Rotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_Rotation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_Rotation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_Rotation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_Rotation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_Rotation";
  }
  protected:
  explicit Grid_Rotation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotaXFieldNumber = 1,
    kRotaYFieldNumber = 2,
    kRotaZFieldNumber = 3,
  };
  // uint32 RotaX = 1;
  void clear_rotax();
  uint32_t rotax() const;
  void set_rotax(uint32_t value);
  private:
  uint32_t _internal_rotax() const;
  void _internal_set_rotax(uint32_t value);
  public:

  // uint32 RotaY = 2;
  void clear_rotay();
  uint32_t rotay() const;
  void set_rotay(uint32_t value);
  private:
  uint32_t _internal_rotay() const;
  void _internal_set_rotay(uint32_t value);
  public:

  // uint32 RotaZ = 3;
  void clear_rotaz();
  uint32_t rotaz() const;
  void set_rotaz(uint32_t value);
  private:
  uint32_t _internal_rotaz() const;
  void _internal_set_rotaz(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Grid_Rotation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t rotax_;
  uint32_t rotay_;
  uint32_t rotaz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Grid_Rect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_Rect) */ {
 public:
  inline Grid_Rect() : Grid_Rect(nullptr) {}
  ~Grid_Rect() override;
  explicit PROTOBUF_CONSTEXPR Grid_Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_Rect(const Grid_Rect& from);
  Grid_Rect(Grid_Rect&& from) noexcept
    : Grid_Rect() {
    *this = ::std::move(from);
  }

  inline Grid_Rect& operator=(const Grid_Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_Rect& operator=(Grid_Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_Rect* internal_default_instance() {
    return reinterpret_cast<const Grid_Rect*>(
               &_Grid_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Grid_Rect& a, Grid_Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_Rect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_Rect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_Rect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_Rect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_Rect";
  }
  protected:
  explicit Grid_Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinPosFieldNumber = 1,
    kMaxPosFieldNumber = 2,
  };
  // .packet.Grid_Point minPos = 1;
  bool has_minpos() const;
  private:
  bool _internal_has_minpos() const;
  public:
  void clear_minpos();
  const ::packet::Grid_Point& minpos() const;
  PROTOBUF_NODISCARD ::packet::Grid_Point* release_minpos();
  ::packet::Grid_Point* mutable_minpos();
  void set_allocated_minpos(::packet::Grid_Point* minpos);
  private:
  const ::packet::Grid_Point& _internal_minpos() const;
  ::packet::Grid_Point* _internal_mutable_minpos();
  public:
  void unsafe_arena_set_allocated_minpos(
      ::packet::Grid_Point* minpos);
  ::packet::Grid_Point* unsafe_arena_release_minpos();

  // .packet.Grid_Point maxPos = 2;
  bool has_maxpos() const;
  private:
  bool _internal_has_maxpos() const;
  public:
  void clear_maxpos();
  const ::packet::Grid_Point& maxpos() const;
  PROTOBUF_NODISCARD ::packet::Grid_Point* release_maxpos();
  ::packet::Grid_Point* mutable_maxpos();
  void set_allocated_maxpos(::packet::Grid_Point* maxpos);
  private:
  const ::packet::Grid_Point& _internal_maxpos() const;
  ::packet::Grid_Point* _internal_mutable_maxpos();
  public:
  void unsafe_arena_set_allocated_maxpos(
      ::packet::Grid_Point* maxpos);
  ::packet::Grid_Point* unsafe_arena_release_maxpos();

  // @@protoc_insertion_point(class_scope:packet.Grid_Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::packet::Grid_Point* minpos_;
  ::packet::Grid_Point* maxpos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Grid_RigNPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_RigNPC) */ {
 public:
  inline Grid_RigNPC() : Grid_RigNPC(nullptr) {}
  ~Grid_RigNPC() override;
  explicit PROTOBUF_CONSTEXPR Grid_RigNPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_RigNPC(const Grid_RigNPC& from);
  Grid_RigNPC(Grid_RigNPC&& from) noexcept
    : Grid_RigNPC() {
    *this = ::std::move(from);
  }

  inline Grid_RigNPC& operator=(const Grid_RigNPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_RigNPC& operator=(Grid_RigNPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_RigNPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_RigNPC* internal_default_instance() {
    return reinterpret_cast<const Grid_RigNPC*>(
               &_Grid_RigNPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Grid_RigNPC& a, Grid_RigNPC& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_RigNPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_RigNPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_RigNPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_RigNPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_RigNPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_RigNPC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_RigNPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_RigNPC";
  }
  protected:
  explicit Grid_RigNPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerRectFieldNumber = 2,
    kRotaFieldNumber = 3,
    kPosFieldNumber = 4,
    kTriggerRectSecondFieldNumber = 5,
    kNpcIdFieldNumber = 1,
  };
  // .packet.Grid_Rect triggerRect = 2;
  bool has_triggerrect() const;
  private:
  bool _internal_has_triggerrect() const;
  public:
  void clear_triggerrect();
  const ::packet::Grid_Rect& triggerrect() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rect* release_triggerrect();
  ::packet::Grid_Rect* mutable_triggerrect();
  void set_allocated_triggerrect(::packet::Grid_Rect* triggerrect);
  private:
  const ::packet::Grid_Rect& _internal_triggerrect() const;
  ::packet::Grid_Rect* _internal_mutable_triggerrect();
  public:
  void unsafe_arena_set_allocated_triggerrect(
      ::packet::Grid_Rect* triggerrect);
  ::packet::Grid_Rect* unsafe_arena_release_triggerrect();

  // .packet.Grid_Rotation rota = 3;
  bool has_rota() const;
  private:
  bool _internal_has_rota() const;
  public:
  void clear_rota();
  const ::packet::Grid_Rotation& rota() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rotation* release_rota();
  ::packet::Grid_Rotation* mutable_rota();
  void set_allocated_rota(::packet::Grid_Rotation* rota);
  private:
  const ::packet::Grid_Rotation& _internal_rota() const;
  ::packet::Grid_Rotation* _internal_mutable_rota();
  public:
  void unsafe_arena_set_allocated_rota(
      ::packet::Grid_Rotation* rota);
  ::packet::Grid_Rotation* unsafe_arena_release_rota();

  // .packet.Grid_Point pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::packet::Grid_Point& pos() const;
  PROTOBUF_NODISCARD ::packet::Grid_Point* release_pos();
  ::packet::Grid_Point* mutable_pos();
  void set_allocated_pos(::packet::Grid_Point* pos);
  private:
  const ::packet::Grid_Point& _internal_pos() const;
  ::packet::Grid_Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::packet::Grid_Point* pos);
  ::packet::Grid_Point* unsafe_arena_release_pos();

  // .packet.Grid_Rect triggerRectSecond = 5;
  bool has_triggerrectsecond() const;
  private:
  bool _internal_has_triggerrectsecond() const;
  public:
  void clear_triggerrectsecond();
  const ::packet::Grid_Rect& triggerrectsecond() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rect* release_triggerrectsecond();
  ::packet::Grid_Rect* mutable_triggerrectsecond();
  void set_allocated_triggerrectsecond(::packet::Grid_Rect* triggerrectsecond);
  private:
  const ::packet::Grid_Rect& _internal_triggerrectsecond() const;
  ::packet::Grid_Rect* _internal_mutable_triggerrectsecond();
  public:
  void unsafe_arena_set_allocated_triggerrectsecond(
      ::packet::Grid_Rect* triggerrectsecond);
  ::packet::Grid_Rect* unsafe_arena_release_triggerrectsecond();

  // uint32 npcId = 1;
  void clear_npcid();
  uint32_t npcid() const;
  void set_npcid(uint32_t value);
  private:
  uint32_t _internal_npcid() const;
  void _internal_set_npcid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Grid_RigNPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::packet::Grid_Rect* triggerrect_;
  ::packet::Grid_Rotation* rota_;
  ::packet::Grid_Point* pos_;
  ::packet::Grid_Rect* triggerrectsecond_;
  uint32_t npcid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Map_RigNPC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Map_RigNPC) */ {
 public:
  inline Map_RigNPC() : Map_RigNPC(nullptr) {}
  ~Map_RigNPC() override;
  explicit PROTOBUF_CONSTEXPR Map_RigNPC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_RigNPC(const Map_RigNPC& from);
  Map_RigNPC(Map_RigNPC&& from) noexcept
    : Map_RigNPC() {
    *this = ::std::move(from);
  }

  inline Map_RigNPC& operator=(const Map_RigNPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_RigNPC& operator=(Map_RigNPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_RigNPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_RigNPC* internal_default_instance() {
    return reinterpret_cast<const Map_RigNPC*>(
               &_Map_RigNPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Map_RigNPC& a, Map_RigNPC& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_RigNPC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_RigNPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_RigNPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_RigNPC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_RigNPC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Map_RigNPC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_RigNPC* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Map_RigNPC";
  }
  protected:
  explicit Map_RigNPC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecGridsFieldNumber = 1,
  };
  // repeated .packet.Grid_RigNPC vecGrids = 1;
  int vecgrids_size() const;
  private:
  int _internal_vecgrids_size() const;
  public:
  void clear_vecgrids();
  ::packet::Grid_RigNPC* mutable_vecgrids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_RigNPC >*
      mutable_vecgrids();
  private:
  const ::packet::Grid_RigNPC& _internal_vecgrids(int index) const;
  ::packet::Grid_RigNPC* _internal_add_vecgrids();
  public:
  const ::packet::Grid_RigNPC& vecgrids(int index) const;
  ::packet::Grid_RigNPC* add_vecgrids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_RigNPC >&
      vecgrids() const;

  // @@protoc_insertion_point(class_scope:packet.Map_RigNPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_RigNPC > vecgrids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Grid_Teleporter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_Teleporter) */ {
 public:
  inline Grid_Teleporter() : Grid_Teleporter(nullptr) {}
  ~Grid_Teleporter() override;
  explicit PROTOBUF_CONSTEXPR Grid_Teleporter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_Teleporter(const Grid_Teleporter& from);
  Grid_Teleporter(Grid_Teleporter&& from) noexcept
    : Grid_Teleporter() {
    *this = ::std::move(from);
  }

  inline Grid_Teleporter& operator=(const Grid_Teleporter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_Teleporter& operator=(Grid_Teleporter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_Teleporter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_Teleporter* internal_default_instance() {
    return reinterpret_cast<const Grid_Teleporter*>(
               &_Grid_Teleporter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Grid_Teleporter& a, Grid_Teleporter& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_Teleporter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_Teleporter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_Teleporter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_Teleporter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_Teleporter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_Teleporter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_Teleporter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_Teleporter";
  }
  protected:
  explicit Grid_Teleporter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerRectFieldNumber = 4,
    kRotaFieldNumber = 5,
    kPosFieldNumber = 6,
    kTelTypeFieldNumber = 1,
    kTargetMapFieldNumber = 2,
    kTelAnimFieldNumber = 3,
  };
  // .packet.Grid_Rect triggerRect = 4;
  bool has_triggerrect() const;
  private:
  bool _internal_has_triggerrect() const;
  public:
  void clear_triggerrect();
  const ::packet::Grid_Rect& triggerrect() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rect* release_triggerrect();
  ::packet::Grid_Rect* mutable_triggerrect();
  void set_allocated_triggerrect(::packet::Grid_Rect* triggerrect);
  private:
  const ::packet::Grid_Rect& _internal_triggerrect() const;
  ::packet::Grid_Rect* _internal_mutable_triggerrect();
  public:
  void unsafe_arena_set_allocated_triggerrect(
      ::packet::Grid_Rect* triggerrect);
  ::packet::Grid_Rect* unsafe_arena_release_triggerrect();

  // .packet.Grid_Rotation rota = 5;
  bool has_rota() const;
  private:
  bool _internal_has_rota() const;
  public:
  void clear_rota();
  const ::packet::Grid_Rotation& rota() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rotation* release_rota();
  ::packet::Grid_Rotation* mutable_rota();
  void set_allocated_rota(::packet::Grid_Rotation* rota);
  private:
  const ::packet::Grid_Rotation& _internal_rota() const;
  ::packet::Grid_Rotation* _internal_mutable_rota();
  public:
  void unsafe_arena_set_allocated_rota(
      ::packet::Grid_Rotation* rota);
  ::packet::Grid_Rotation* unsafe_arena_release_rota();

  // .packet.Grid_Point pos = 6;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::packet::Grid_Point& pos() const;
  PROTOBUF_NODISCARD ::packet::Grid_Point* release_pos();
  ::packet::Grid_Point* mutable_pos();
  void set_allocated_pos(::packet::Grid_Point* pos);
  private:
  const ::packet::Grid_Point& _internal_pos() const;
  ::packet::Grid_Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::packet::Grid_Point* pos);
  ::packet::Grid_Point* unsafe_arena_release_pos();

  // uint32 telType = 1;
  void clear_teltype();
  uint32_t teltype() const;
  void set_teltype(uint32_t value);
  private:
  uint32_t _internal_teltype() const;
  void _internal_set_teltype(uint32_t value);
  public:

  // uint32 targetMap = 2;
  void clear_targetmap();
  uint32_t targetmap() const;
  void set_targetmap(uint32_t value);
  private:
  uint32_t _internal_targetmap() const;
  void _internal_set_targetmap(uint32_t value);
  public:

  // uint32 telAnim = 3;
  void clear_telanim();
  uint32_t telanim() const;
  void set_telanim(uint32_t value);
  private:
  uint32_t _internal_telanim() const;
  void _internal_set_telanim(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Grid_Teleporter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::packet::Grid_Rect* triggerrect_;
  ::packet::Grid_Rotation* rota_;
  ::packet::Grid_Point* pos_;
  uint32_t teltype_;
  uint32_t targetmap_;
  uint32_t telanim_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Map_Teleporter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Map_Teleporter) */ {
 public:
  inline Map_Teleporter() : Map_Teleporter(nullptr) {}
  ~Map_Teleporter() override;
  explicit PROTOBUF_CONSTEXPR Map_Teleporter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_Teleporter(const Map_Teleporter& from);
  Map_Teleporter(Map_Teleporter&& from) noexcept
    : Map_Teleporter() {
    *this = ::std::move(from);
  }

  inline Map_Teleporter& operator=(const Map_Teleporter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_Teleporter& operator=(Map_Teleporter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_Teleporter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_Teleporter* internal_default_instance() {
    return reinterpret_cast<const Map_Teleporter*>(
               &_Map_Teleporter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Map_Teleporter& a, Map_Teleporter& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_Teleporter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_Teleporter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_Teleporter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_Teleporter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_Teleporter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Map_Teleporter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_Teleporter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Map_Teleporter";
  }
  protected:
  explicit Map_Teleporter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecGridsFieldNumber = 1,
  };
  // repeated .packet.Grid_Teleporter vecGrids = 1;
  int vecgrids_size() const;
  private:
  int _internal_vecgrids_size() const;
  public:
  void clear_vecgrids();
  ::packet::Grid_Teleporter* mutable_vecgrids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_Teleporter >*
      mutable_vecgrids();
  private:
  const ::packet::Grid_Teleporter& _internal_vecgrids(int index) const;
  ::packet::Grid_Teleporter* _internal_add_vecgrids();
  public:
  const ::packet::Grid_Teleporter& vecgrids(int index) const;
  ::packet::Grid_Teleporter* add_vecgrids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_Teleporter >&
      vecgrids() const;

  // @@protoc_insertion_point(class_scope:packet.Map_Teleporter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_Teleporter > vecgrids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Grid_BlockArea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_BlockArea) */ {
 public:
  inline Grid_BlockArea() : Grid_BlockArea(nullptr) {}
  ~Grid_BlockArea() override;
  explicit PROTOBUF_CONSTEXPR Grid_BlockArea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_BlockArea(const Grid_BlockArea& from);
  Grid_BlockArea(Grid_BlockArea&& from) noexcept
    : Grid_BlockArea() {
    *this = ::std::move(from);
  }

  inline Grid_BlockArea& operator=(const Grid_BlockArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_BlockArea& operator=(Grid_BlockArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_BlockArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_BlockArea* internal_default_instance() {
    return reinterpret_cast<const Grid_BlockArea*>(
               &_Grid_BlockArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Grid_BlockArea& a, Grid_BlockArea& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_BlockArea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_BlockArea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_BlockArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_BlockArea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_BlockArea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_BlockArea& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_BlockArea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_BlockArea";
  }
  protected:
  explicit Grid_BlockArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockRectFieldNumber = 2,
    kInstanceIdFieldNumber = 3,
    kBlockAreaIdFieldNumber = 1,
  };
  // .packet.Grid_Rect blockRect = 2;
  bool has_blockrect() const;
  private:
  bool _internal_has_blockrect() const;
  public:
  void clear_blockrect();
  const ::packet::Grid_Rect& blockrect() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rect* release_blockrect();
  ::packet::Grid_Rect* mutable_blockrect();
  void set_allocated_blockrect(::packet::Grid_Rect* blockrect);
  private:
  const ::packet::Grid_Rect& _internal_blockrect() const;
  ::packet::Grid_Rect* _internal_mutable_blockrect();
  public:
  void unsafe_arena_set_allocated_blockrect(
      ::packet::Grid_Rect* blockrect);
  ::packet::Grid_Rect* unsafe_arena_release_blockrect();

  // uint64 instanceId = 3;
  void clear_instanceid();
  uint64_t instanceid() const;
  void set_instanceid(uint64_t value);
  private:
  uint64_t _internal_instanceid() const;
  void _internal_set_instanceid(uint64_t value);
  public:

  // uint32 blockAreaId = 1;
  void clear_blockareaid();
  uint32_t blockareaid() const;
  void set_blockareaid(uint32_t value);
  private:
  uint32_t _internal_blockareaid() const;
  void _internal_set_blockareaid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Grid_BlockArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::packet::Grid_Rect* blockrect_;
  uint64_t instanceid_;
  uint32_t blockareaid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Map_BlockArea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Map_BlockArea) */ {
 public:
  inline Map_BlockArea() : Map_BlockArea(nullptr) {}
  ~Map_BlockArea() override;
  explicit PROTOBUF_CONSTEXPR Map_BlockArea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_BlockArea(const Map_BlockArea& from);
  Map_BlockArea(Map_BlockArea&& from) noexcept
    : Map_BlockArea() {
    *this = ::std::move(from);
  }

  inline Map_BlockArea& operator=(const Map_BlockArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_BlockArea& operator=(Map_BlockArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_BlockArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_BlockArea* internal_default_instance() {
    return reinterpret_cast<const Map_BlockArea*>(
               &_Map_BlockArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Map_BlockArea& a, Map_BlockArea& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_BlockArea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_BlockArea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_BlockArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_BlockArea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_BlockArea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Map_BlockArea& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_BlockArea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Map_BlockArea";
  }
  protected:
  explicit Map_BlockArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecGridsFieldNumber = 1,
  };
  // repeated .packet.Grid_BlockArea vecGrids = 1;
  int vecgrids_size() const;
  private:
  int _internal_vecgrids_size() const;
  public:
  void clear_vecgrids();
  ::packet::Grid_BlockArea* mutable_vecgrids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_BlockArea >*
      mutable_vecgrids();
  private:
  const ::packet::Grid_BlockArea& _internal_vecgrids(int index) const;
  ::packet::Grid_BlockArea* _internal_add_vecgrids();
  public:
  const ::packet::Grid_BlockArea& vecgrids(int index) const;
  ::packet::Grid_BlockArea* add_vecgrids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_BlockArea >&
      vecgrids() const;

  // @@protoc_insertion_point(class_scope:packet.Map_BlockArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_BlockArea > vecgrids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Grid_MonsterGroup_Grid_MonsterGroupUnit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit) */ {
 public:
  inline Grid_MonsterGroup_Grid_MonsterGroupUnit() : Grid_MonsterGroup_Grid_MonsterGroupUnit(nullptr) {}
  ~Grid_MonsterGroup_Grid_MonsterGroupUnit() override;
  explicit PROTOBUF_CONSTEXPR Grid_MonsterGroup_Grid_MonsterGroupUnit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_MonsterGroup_Grid_MonsterGroupUnit(const Grid_MonsterGroup_Grid_MonsterGroupUnit& from);
  Grid_MonsterGroup_Grid_MonsterGroupUnit(Grid_MonsterGroup_Grid_MonsterGroupUnit&& from) noexcept
    : Grid_MonsterGroup_Grid_MonsterGroupUnit() {
    *this = ::std::move(from);
  }

  inline Grid_MonsterGroup_Grid_MonsterGroupUnit& operator=(const Grid_MonsterGroup_Grid_MonsterGroupUnit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_MonsterGroup_Grid_MonsterGroupUnit& operator=(Grid_MonsterGroup_Grid_MonsterGroupUnit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_MonsterGroup_Grid_MonsterGroupUnit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_MonsterGroup_Grid_MonsterGroupUnit* internal_default_instance() {
    return reinterpret_cast<const Grid_MonsterGroup_Grid_MonsterGroupUnit*>(
               &_Grid_MonsterGroup_Grid_MonsterGroupUnit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Grid_MonsterGroup_Grid_MonsterGroupUnit& a, Grid_MonsterGroup_Grid_MonsterGroupUnit& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_MonsterGroup_Grid_MonsterGroupUnit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_MonsterGroup_Grid_MonsterGroupUnit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_MonsterGroup_Grid_MonsterGroupUnit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_MonsterGroup_Grid_MonsterGroupUnit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_MonsterGroup_Grid_MonsterGroupUnit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_MonsterGroup_Grid_MonsterGroupUnit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_MonsterGroup_Grid_MonsterGroupUnit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_MonsterGroup.Grid_MonsterGroupUnit";
  }
  protected:
  explicit Grid_MonsterGroup_Grid_MonsterGroupUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateRectFieldNumber = 2,
    kRotaFieldNumber = 3,
    kPosFieldNumber = 4,
    kMonsterGroupIdFieldNumber = 1,
  };
  // .packet.Grid_Rect createRect = 2;
  bool has_createrect() const;
  private:
  bool _internal_has_createrect() const;
  public:
  void clear_createrect();
  const ::packet::Grid_Rect& createrect() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rect* release_createrect();
  ::packet::Grid_Rect* mutable_createrect();
  void set_allocated_createrect(::packet::Grid_Rect* createrect);
  private:
  const ::packet::Grid_Rect& _internal_createrect() const;
  ::packet::Grid_Rect* _internal_mutable_createrect();
  public:
  void unsafe_arena_set_allocated_createrect(
      ::packet::Grid_Rect* createrect);
  ::packet::Grid_Rect* unsafe_arena_release_createrect();

  // .packet.Grid_Rotation rota = 3;
  bool has_rota() const;
  private:
  bool _internal_has_rota() const;
  public:
  void clear_rota();
  const ::packet::Grid_Rotation& rota() const;
  PROTOBUF_NODISCARD ::packet::Grid_Rotation* release_rota();
  ::packet::Grid_Rotation* mutable_rota();
  void set_allocated_rota(::packet::Grid_Rotation* rota);
  private:
  const ::packet::Grid_Rotation& _internal_rota() const;
  ::packet::Grid_Rotation* _internal_mutable_rota();
  public:
  void unsafe_arena_set_allocated_rota(
      ::packet::Grid_Rotation* rota);
  ::packet::Grid_Rotation* unsafe_arena_release_rota();

  // .packet.Grid_Point pos = 4;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::packet::Grid_Point& pos() const;
  PROTOBUF_NODISCARD ::packet::Grid_Point* release_pos();
  ::packet::Grid_Point* mutable_pos();
  void set_allocated_pos(::packet::Grid_Point* pos);
  private:
  const ::packet::Grid_Point& _internal_pos() const;
  ::packet::Grid_Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::packet::Grid_Point* pos);
  ::packet::Grid_Point* unsafe_arena_release_pos();

  // uint32 monsterGroupId = 1;
  void clear_monstergroupid();
  uint32_t monstergroupid() const;
  void set_monstergroupid(uint32_t value);
  private:
  uint32_t _internal_monstergroupid() const;
  void _internal_set_monstergroupid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::packet::Grid_Rect* createrect_;
  ::packet::Grid_Rotation* rota_;
  ::packet::Grid_Point* pos_;
  uint32_t monstergroupid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Grid_MonsterGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Grid_MonsterGroup) */ {
 public:
  inline Grid_MonsterGroup() : Grid_MonsterGroup(nullptr) {}
  ~Grid_MonsterGroup() override;
  explicit PROTOBUF_CONSTEXPR Grid_MonsterGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Grid_MonsterGroup(const Grid_MonsterGroup& from);
  Grid_MonsterGroup(Grid_MonsterGroup&& from) noexcept
    : Grid_MonsterGroup() {
    *this = ::std::move(from);
  }

  inline Grid_MonsterGroup& operator=(const Grid_MonsterGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Grid_MonsterGroup& operator=(Grid_MonsterGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Grid_MonsterGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Grid_MonsterGroup* internal_default_instance() {
    return reinterpret_cast<const Grid_MonsterGroup*>(
               &_Grid_MonsterGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Grid_MonsterGroup& a, Grid_MonsterGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(Grid_MonsterGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Grid_MonsterGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Grid_MonsterGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Grid_MonsterGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Grid_MonsterGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Grid_MonsterGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Grid_MonsterGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Grid_MonsterGroup";
  }
  protected:
  explicit Grid_MonsterGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Grid_MonsterGroup_Grid_MonsterGroupUnit Grid_MonsterGroupUnit;

  // accessors -------------------------------------------------------

  enum : int {
    kVecGroupsFieldNumber = 1,
  };
  // repeated .packet.Grid_MonsterGroup.Grid_MonsterGroupUnit vecGroups = 1;
  int vecgroups_size() const;
  private:
  int _internal_vecgroups_size() const;
  public:
  void clear_vecgroups();
  ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* mutable_vecgroups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit >*
      mutable_vecgroups();
  private:
  const ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit& _internal_vecgroups(int index) const;
  ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* _internal_add_vecgroups();
  public:
  const ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit& vecgroups(int index) const;
  ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* add_vecgroups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit >&
      vecgroups() const;

  // @@protoc_insertion_point(class_scope:packet.Grid_MonsterGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit > vecgroups_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Map_MonsterGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Map_MonsterGroup) */ {
 public:
  inline Map_MonsterGroup() : Map_MonsterGroup(nullptr) {}
  ~Map_MonsterGroup() override;
  explicit PROTOBUF_CONSTEXPR Map_MonsterGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_MonsterGroup(const Map_MonsterGroup& from);
  Map_MonsterGroup(Map_MonsterGroup&& from) noexcept
    : Map_MonsterGroup() {
    *this = ::std::move(from);
  }

  inline Map_MonsterGroup& operator=(const Map_MonsterGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_MonsterGroup& operator=(Map_MonsterGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_MonsterGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_MonsterGroup* internal_default_instance() {
    return reinterpret_cast<const Map_MonsterGroup*>(
               &_Map_MonsterGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Map_MonsterGroup& a, Map_MonsterGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_MonsterGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_MonsterGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_MonsterGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_MonsterGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_MonsterGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Map_MonsterGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_MonsterGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Map_MonsterGroup";
  }
  protected:
  explicit Map_MonsterGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVecGridsFieldNumber = 1,
  };
  // repeated .packet.Grid_MonsterGroup vecGrids = 1;
  int vecgrids_size() const;
  private:
  int _internal_vecgrids_size() const;
  public:
  void clear_vecgrids();
  ::packet::Grid_MonsterGroup* mutable_vecgrids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup >*
      mutable_vecgrids();
  private:
  const ::packet::Grid_MonsterGroup& _internal_vecgrids(int index) const;
  ::packet::Grid_MonsterGroup* _internal_add_vecgrids();
  public:
  const ::packet::Grid_MonsterGroup& vecgrids(int index) const;
  ::packet::Grid_MonsterGroup* add_vecgrids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup >&
      vecgrids() const;

  // @@protoc_insertion_point(class_scope:packet.Map_MonsterGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup > vecgrids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Map_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Map_Info) */ {
 public:
  inline Map_Info() : Map_Info(nullptr) {}
  ~Map_Info() override;
  explicit PROTOBUF_CONSTEXPR Map_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_Info(const Map_Info& from);
  Map_Info(Map_Info&& from) noexcept
    : Map_Info() {
    *this = ::std::move(from);
  }

  inline Map_Info& operator=(const Map_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_Info& operator=(Map_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_Info* internal_default_instance() {
    return reinterpret_cast<const Map_Info*>(
               &_Map_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Map_Info& a, Map_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Map_Info& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Map_Info";
  }
  protected:
  explicit Map_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // uint32 width = 1;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 2;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Map_Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t width_;
  uint32_t height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// -------------------------------------------------------------------

class Map_AllTypes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:packet.Map_AllTypes) */ {
 public:
  inline Map_AllTypes() : Map_AllTypes(nullptr) {}
  ~Map_AllTypes() override;
  explicit PROTOBUF_CONSTEXPR Map_AllTypes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Map_AllTypes(const Map_AllTypes& from);
  Map_AllTypes(Map_AllTypes&& from) noexcept
    : Map_AllTypes() {
    *this = ::std::move(from);
  }

  inline Map_AllTypes& operator=(const Map_AllTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline Map_AllTypes& operator=(Map_AllTypes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Map_AllTypes& default_instance() {
    return *internal_default_instance();
  }
  static inline const Map_AllTypes* internal_default_instance() {
    return reinterpret_cast<const Map_AllTypes*>(
               &_Map_AllTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Map_AllTypes& a, Map_AllTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(Map_AllTypes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Map_AllTypes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Map_AllTypes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Map_AllTypes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Map_AllTypes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Map_AllTypes& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Map_AllTypes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "packet.Map_AllTypes";
  }
  protected:
  explicit Map_AllTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapRigNPCFieldNumber = 2,
    kMapTelFieldNumber = 3,
    kMapBlockFieldNumber = 4,
    kMapMonsterGroupFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // .packet.Map_RigNPC mapRigNPC = 2;
  bool has_maprignpc() const;
  private:
  bool _internal_has_maprignpc() const;
  public:
  void clear_maprignpc();
  const ::packet::Map_RigNPC& maprignpc() const;
  PROTOBUF_NODISCARD ::packet::Map_RigNPC* release_maprignpc();
  ::packet::Map_RigNPC* mutable_maprignpc();
  void set_allocated_maprignpc(::packet::Map_RigNPC* maprignpc);
  private:
  const ::packet::Map_RigNPC& _internal_maprignpc() const;
  ::packet::Map_RigNPC* _internal_mutable_maprignpc();
  public:
  void unsafe_arena_set_allocated_maprignpc(
      ::packet::Map_RigNPC* maprignpc);
  ::packet::Map_RigNPC* unsafe_arena_release_maprignpc();

  // .packet.Map_Teleporter mapTel = 3;
  bool has_maptel() const;
  private:
  bool _internal_has_maptel() const;
  public:
  void clear_maptel();
  const ::packet::Map_Teleporter& maptel() const;
  PROTOBUF_NODISCARD ::packet::Map_Teleporter* release_maptel();
  ::packet::Map_Teleporter* mutable_maptel();
  void set_allocated_maptel(::packet::Map_Teleporter* maptel);
  private:
  const ::packet::Map_Teleporter& _internal_maptel() const;
  ::packet::Map_Teleporter* _internal_mutable_maptel();
  public:
  void unsafe_arena_set_allocated_maptel(
      ::packet::Map_Teleporter* maptel);
  ::packet::Map_Teleporter* unsafe_arena_release_maptel();

  // .packet.Map_BlockArea mapBlock = 4;
  bool has_mapblock() const;
  private:
  bool _internal_has_mapblock() const;
  public:
  void clear_mapblock();
  const ::packet::Map_BlockArea& mapblock() const;
  PROTOBUF_NODISCARD ::packet::Map_BlockArea* release_mapblock();
  ::packet::Map_BlockArea* mutable_mapblock();
  void set_allocated_mapblock(::packet::Map_BlockArea* mapblock);
  private:
  const ::packet::Map_BlockArea& _internal_mapblock() const;
  ::packet::Map_BlockArea* _internal_mutable_mapblock();
  public:
  void unsafe_arena_set_allocated_mapblock(
      ::packet::Map_BlockArea* mapblock);
  ::packet::Map_BlockArea* unsafe_arena_release_mapblock();

  // .packet.Map_MonsterGroup mapMonsterGroup = 5;
  bool has_mapmonstergroup() const;
  private:
  bool _internal_has_mapmonstergroup() const;
  public:
  void clear_mapmonstergroup();
  const ::packet::Map_MonsterGroup& mapmonstergroup() const;
  PROTOBUF_NODISCARD ::packet::Map_MonsterGroup* release_mapmonstergroup();
  ::packet::Map_MonsterGroup* mutable_mapmonstergroup();
  void set_allocated_mapmonstergroup(::packet::Map_MonsterGroup* mapmonstergroup);
  private:
  const ::packet::Map_MonsterGroup& _internal_mapmonstergroup() const;
  ::packet::Map_MonsterGroup* _internal_mutable_mapmonstergroup();
  public:
  void unsafe_arena_set_allocated_mapmonstergroup(
      ::packet::Map_MonsterGroup* mapmonstergroup);
  ::packet::Map_MonsterGroup* unsafe_arena_release_mapmonstergroup();

  // .packet.BrushType type = 1;
  void clear_type();
  ::packet::BrushType type() const;
  void set_type(::packet::BrushType value);
  private:
  ::packet::BrushType _internal_type() const;
  void _internal_set_type(::packet::BrushType value);
  public:

  // @@protoc_insertion_point(class_scope:packet.Map_AllTypes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::packet::Map_RigNPC* maprignpc_;
  ::packet::Map_Teleporter* maptel_;
  ::packet::Map_BlockArea* mapblock_;
  ::packet::Map_MonsterGroup* mapmonstergroup_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_5fcfg_5fins_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Grid_Point

// uint32 PosX = 1;
inline void Grid_Point::clear_posx() {
  posx_ = 0u;
}
inline uint32_t Grid_Point::_internal_posx() const {
  return posx_;
}
inline uint32_t Grid_Point::posx() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Point.PosX)
  return _internal_posx();
}
inline void Grid_Point::_internal_set_posx(uint32_t value) {
  
  posx_ = value;
}
inline void Grid_Point::set_posx(uint32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Point.PosX)
}

// uint32 PosY = 2;
inline void Grid_Point::clear_posy() {
  posy_ = 0u;
}
inline uint32_t Grid_Point::_internal_posy() const {
  return posy_;
}
inline uint32_t Grid_Point::posy() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Point.PosY)
  return _internal_posy();
}
inline void Grid_Point::_internal_set_posy(uint32_t value) {
  
  posy_ = value;
}
inline void Grid_Point::set_posy(uint32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Point.PosY)
}

// -------------------------------------------------------------------

// Grid_Rotation

// uint32 RotaX = 1;
inline void Grid_Rotation::clear_rotax() {
  rotax_ = 0u;
}
inline uint32_t Grid_Rotation::_internal_rotax() const {
  return rotax_;
}
inline uint32_t Grid_Rotation::rotax() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Rotation.RotaX)
  return _internal_rotax();
}
inline void Grid_Rotation::_internal_set_rotax(uint32_t value) {
  
  rotax_ = value;
}
inline void Grid_Rotation::set_rotax(uint32_t value) {
  _internal_set_rotax(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Rotation.RotaX)
}

// uint32 RotaY = 2;
inline void Grid_Rotation::clear_rotay() {
  rotay_ = 0u;
}
inline uint32_t Grid_Rotation::_internal_rotay() const {
  return rotay_;
}
inline uint32_t Grid_Rotation::rotay() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Rotation.RotaY)
  return _internal_rotay();
}
inline void Grid_Rotation::_internal_set_rotay(uint32_t value) {
  
  rotay_ = value;
}
inline void Grid_Rotation::set_rotay(uint32_t value) {
  _internal_set_rotay(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Rotation.RotaY)
}

// uint32 RotaZ = 3;
inline void Grid_Rotation::clear_rotaz() {
  rotaz_ = 0u;
}
inline uint32_t Grid_Rotation::_internal_rotaz() const {
  return rotaz_;
}
inline uint32_t Grid_Rotation::rotaz() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Rotation.RotaZ)
  return _internal_rotaz();
}
inline void Grid_Rotation::_internal_set_rotaz(uint32_t value) {
  
  rotaz_ = value;
}
inline void Grid_Rotation::set_rotaz(uint32_t value) {
  _internal_set_rotaz(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Rotation.RotaZ)
}

// -------------------------------------------------------------------

// Grid_Rect

// .packet.Grid_Point minPos = 1;
inline bool Grid_Rect::_internal_has_minpos() const {
  return this != internal_default_instance() && minpos_ != nullptr;
}
inline bool Grid_Rect::has_minpos() const {
  return _internal_has_minpos();
}
inline void Grid_Rect::clear_minpos() {
  if (GetArenaForAllocation() == nullptr && minpos_ != nullptr) {
    delete minpos_;
  }
  minpos_ = nullptr;
}
inline const ::packet::Grid_Point& Grid_Rect::_internal_minpos() const {
  const ::packet::Grid_Point* p = minpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Point&>(
      ::packet::_Grid_Point_default_instance_);
}
inline const ::packet::Grid_Point& Grid_Rect::minpos() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Rect.minPos)
  return _internal_minpos();
}
inline void Grid_Rect::unsafe_arena_set_allocated_minpos(
    ::packet::Grid_Point* minpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minpos_);
  }
  minpos_ = minpos;
  if (minpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_Rect.minPos)
}
inline ::packet::Grid_Point* Grid_Rect::release_minpos() {
  
  ::packet::Grid_Point* temp = minpos_;
  minpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Point* Grid_Rect::unsafe_arena_release_minpos() {
  // @@protoc_insertion_point(field_release:packet.Grid_Rect.minPos)
  
  ::packet::Grid_Point* temp = minpos_;
  minpos_ = nullptr;
  return temp;
}
inline ::packet::Grid_Point* Grid_Rect::_internal_mutable_minpos() {
  
  if (minpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Point>(GetArenaForAllocation());
    minpos_ = p;
  }
  return minpos_;
}
inline ::packet::Grid_Point* Grid_Rect::mutable_minpos() {
  ::packet::Grid_Point* _msg = _internal_mutable_minpos();
  // @@protoc_insertion_point(field_mutable:packet.Grid_Rect.minPos)
  return _msg;
}
inline void Grid_Rect::set_allocated_minpos(::packet::Grid_Point* minpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete minpos_;
  }
  if (minpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(minpos);
    if (message_arena != submessage_arena) {
      minpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minpos, submessage_arena);
    }
    
  } else {
    
  }
  minpos_ = minpos;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_Rect.minPos)
}

// .packet.Grid_Point maxPos = 2;
inline bool Grid_Rect::_internal_has_maxpos() const {
  return this != internal_default_instance() && maxpos_ != nullptr;
}
inline bool Grid_Rect::has_maxpos() const {
  return _internal_has_maxpos();
}
inline void Grid_Rect::clear_maxpos() {
  if (GetArenaForAllocation() == nullptr && maxpos_ != nullptr) {
    delete maxpos_;
  }
  maxpos_ = nullptr;
}
inline const ::packet::Grid_Point& Grid_Rect::_internal_maxpos() const {
  const ::packet::Grid_Point* p = maxpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Point&>(
      ::packet::_Grid_Point_default_instance_);
}
inline const ::packet::Grid_Point& Grid_Rect::maxpos() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Rect.maxPos)
  return _internal_maxpos();
}
inline void Grid_Rect::unsafe_arena_set_allocated_maxpos(
    ::packet::Grid_Point* maxpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maxpos_);
  }
  maxpos_ = maxpos;
  if (maxpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_Rect.maxPos)
}
inline ::packet::Grid_Point* Grid_Rect::release_maxpos() {
  
  ::packet::Grid_Point* temp = maxpos_;
  maxpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Point* Grid_Rect::unsafe_arena_release_maxpos() {
  // @@protoc_insertion_point(field_release:packet.Grid_Rect.maxPos)
  
  ::packet::Grid_Point* temp = maxpos_;
  maxpos_ = nullptr;
  return temp;
}
inline ::packet::Grid_Point* Grid_Rect::_internal_mutable_maxpos() {
  
  if (maxpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Point>(GetArenaForAllocation());
    maxpos_ = p;
  }
  return maxpos_;
}
inline ::packet::Grid_Point* Grid_Rect::mutable_maxpos() {
  ::packet::Grid_Point* _msg = _internal_mutable_maxpos();
  // @@protoc_insertion_point(field_mutable:packet.Grid_Rect.maxPos)
  return _msg;
}
inline void Grid_Rect::set_allocated_maxpos(::packet::Grid_Point* maxpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete maxpos_;
  }
  if (maxpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maxpos);
    if (message_arena != submessage_arena) {
      maxpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maxpos, submessage_arena);
    }
    
  } else {
    
  }
  maxpos_ = maxpos;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_Rect.maxPos)
}

// -------------------------------------------------------------------

// Grid_RigNPC

// uint32 npcId = 1;
inline void Grid_RigNPC::clear_npcid() {
  npcid_ = 0u;
}
inline uint32_t Grid_RigNPC::_internal_npcid() const {
  return npcid_;
}
inline uint32_t Grid_RigNPC::npcid() const {
  // @@protoc_insertion_point(field_get:packet.Grid_RigNPC.npcId)
  return _internal_npcid();
}
inline void Grid_RigNPC::_internal_set_npcid(uint32_t value) {
  
  npcid_ = value;
}
inline void Grid_RigNPC::set_npcid(uint32_t value) {
  _internal_set_npcid(value);
  // @@protoc_insertion_point(field_set:packet.Grid_RigNPC.npcId)
}

// .packet.Grid_Rect triggerRect = 2;
inline bool Grid_RigNPC::_internal_has_triggerrect() const {
  return this != internal_default_instance() && triggerrect_ != nullptr;
}
inline bool Grid_RigNPC::has_triggerrect() const {
  return _internal_has_triggerrect();
}
inline void Grid_RigNPC::clear_triggerrect() {
  if (GetArenaForAllocation() == nullptr && triggerrect_ != nullptr) {
    delete triggerrect_;
  }
  triggerrect_ = nullptr;
}
inline const ::packet::Grid_Rect& Grid_RigNPC::_internal_triggerrect() const {
  const ::packet::Grid_Rect* p = triggerrect_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rect&>(
      ::packet::_Grid_Rect_default_instance_);
}
inline const ::packet::Grid_Rect& Grid_RigNPC::triggerrect() const {
  // @@protoc_insertion_point(field_get:packet.Grid_RigNPC.triggerRect)
  return _internal_triggerrect();
}
inline void Grid_RigNPC::unsafe_arena_set_allocated_triggerrect(
    ::packet::Grid_Rect* triggerrect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(triggerrect_);
  }
  triggerrect_ = triggerrect;
  if (triggerrect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_RigNPC.triggerRect)
}
inline ::packet::Grid_Rect* Grid_RigNPC::release_triggerrect() {
  
  ::packet::Grid_Rect* temp = triggerrect_;
  triggerrect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rect* Grid_RigNPC::unsafe_arena_release_triggerrect() {
  // @@protoc_insertion_point(field_release:packet.Grid_RigNPC.triggerRect)
  
  ::packet::Grid_Rect* temp = triggerrect_;
  triggerrect_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rect* Grid_RigNPC::_internal_mutable_triggerrect() {
  
  if (triggerrect_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rect>(GetArenaForAllocation());
    triggerrect_ = p;
  }
  return triggerrect_;
}
inline ::packet::Grid_Rect* Grid_RigNPC::mutable_triggerrect() {
  ::packet::Grid_Rect* _msg = _internal_mutable_triggerrect();
  // @@protoc_insertion_point(field_mutable:packet.Grid_RigNPC.triggerRect)
  return _msg;
}
inline void Grid_RigNPC::set_allocated_triggerrect(::packet::Grid_Rect* triggerrect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete triggerrect_;
  }
  if (triggerrect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(triggerrect);
    if (message_arena != submessage_arena) {
      triggerrect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, triggerrect, submessage_arena);
    }
    
  } else {
    
  }
  triggerrect_ = triggerrect;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_RigNPC.triggerRect)
}

// .packet.Grid_Rotation rota = 3;
inline bool Grid_RigNPC::_internal_has_rota() const {
  return this != internal_default_instance() && rota_ != nullptr;
}
inline bool Grid_RigNPC::has_rota() const {
  return _internal_has_rota();
}
inline void Grid_RigNPC::clear_rota() {
  if (GetArenaForAllocation() == nullptr && rota_ != nullptr) {
    delete rota_;
  }
  rota_ = nullptr;
}
inline const ::packet::Grid_Rotation& Grid_RigNPC::_internal_rota() const {
  const ::packet::Grid_Rotation* p = rota_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rotation&>(
      ::packet::_Grid_Rotation_default_instance_);
}
inline const ::packet::Grid_Rotation& Grid_RigNPC::rota() const {
  // @@protoc_insertion_point(field_get:packet.Grid_RigNPC.rota)
  return _internal_rota();
}
inline void Grid_RigNPC::unsafe_arena_set_allocated_rota(
    ::packet::Grid_Rotation* rota) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rota_);
  }
  rota_ = rota;
  if (rota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_RigNPC.rota)
}
inline ::packet::Grid_Rotation* Grid_RigNPC::release_rota() {
  
  ::packet::Grid_Rotation* temp = rota_;
  rota_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rotation* Grid_RigNPC::unsafe_arena_release_rota() {
  // @@protoc_insertion_point(field_release:packet.Grid_RigNPC.rota)
  
  ::packet::Grid_Rotation* temp = rota_;
  rota_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rotation* Grid_RigNPC::_internal_mutable_rota() {
  
  if (rota_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rotation>(GetArenaForAllocation());
    rota_ = p;
  }
  return rota_;
}
inline ::packet::Grid_Rotation* Grid_RigNPC::mutable_rota() {
  ::packet::Grid_Rotation* _msg = _internal_mutable_rota();
  // @@protoc_insertion_point(field_mutable:packet.Grid_RigNPC.rota)
  return _msg;
}
inline void Grid_RigNPC::set_allocated_rota(::packet::Grid_Rotation* rota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rota_;
  }
  if (rota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rota);
    if (message_arena != submessage_arena) {
      rota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rota, submessage_arena);
    }
    
  } else {
    
  }
  rota_ = rota;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_RigNPC.rota)
}

// .packet.Grid_Point pos = 4;
inline bool Grid_RigNPC::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool Grid_RigNPC::has_pos() const {
  return _internal_has_pos();
}
inline void Grid_RigNPC::clear_pos() {
  if (GetArenaForAllocation() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::packet::Grid_Point& Grid_RigNPC::_internal_pos() const {
  const ::packet::Grid_Point* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Point&>(
      ::packet::_Grid_Point_default_instance_);
}
inline const ::packet::Grid_Point& Grid_RigNPC::pos() const {
  // @@protoc_insertion_point(field_get:packet.Grid_RigNPC.pos)
  return _internal_pos();
}
inline void Grid_RigNPC::unsafe_arena_set_allocated_pos(
    ::packet::Grid_Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_RigNPC.pos)
}
inline ::packet::Grid_Point* Grid_RigNPC::release_pos() {
  
  ::packet::Grid_Point* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Point* Grid_RigNPC::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:packet.Grid_RigNPC.pos)
  
  ::packet::Grid_Point* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::packet::Grid_Point* Grid_RigNPC::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Point>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::packet::Grid_Point* Grid_RigNPC::mutable_pos() {
  ::packet::Grid_Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:packet.Grid_RigNPC.pos)
  return _msg;
}
inline void Grid_RigNPC::set_allocated_pos(::packet::Grid_Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_RigNPC.pos)
}

// .packet.Grid_Rect triggerRectSecond = 5;
inline bool Grid_RigNPC::_internal_has_triggerrectsecond() const {
  return this != internal_default_instance() && triggerrectsecond_ != nullptr;
}
inline bool Grid_RigNPC::has_triggerrectsecond() const {
  return _internal_has_triggerrectsecond();
}
inline void Grid_RigNPC::clear_triggerrectsecond() {
  if (GetArenaForAllocation() == nullptr && triggerrectsecond_ != nullptr) {
    delete triggerrectsecond_;
  }
  triggerrectsecond_ = nullptr;
}
inline const ::packet::Grid_Rect& Grid_RigNPC::_internal_triggerrectsecond() const {
  const ::packet::Grid_Rect* p = triggerrectsecond_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rect&>(
      ::packet::_Grid_Rect_default_instance_);
}
inline const ::packet::Grid_Rect& Grid_RigNPC::triggerrectsecond() const {
  // @@protoc_insertion_point(field_get:packet.Grid_RigNPC.triggerRectSecond)
  return _internal_triggerrectsecond();
}
inline void Grid_RigNPC::unsafe_arena_set_allocated_triggerrectsecond(
    ::packet::Grid_Rect* triggerrectsecond) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(triggerrectsecond_);
  }
  triggerrectsecond_ = triggerrectsecond;
  if (triggerrectsecond) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_RigNPC.triggerRectSecond)
}
inline ::packet::Grid_Rect* Grid_RigNPC::release_triggerrectsecond() {
  
  ::packet::Grid_Rect* temp = triggerrectsecond_;
  triggerrectsecond_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rect* Grid_RigNPC::unsafe_arena_release_triggerrectsecond() {
  // @@protoc_insertion_point(field_release:packet.Grid_RigNPC.triggerRectSecond)
  
  ::packet::Grid_Rect* temp = triggerrectsecond_;
  triggerrectsecond_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rect* Grid_RigNPC::_internal_mutable_triggerrectsecond() {
  
  if (triggerrectsecond_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rect>(GetArenaForAllocation());
    triggerrectsecond_ = p;
  }
  return triggerrectsecond_;
}
inline ::packet::Grid_Rect* Grid_RigNPC::mutable_triggerrectsecond() {
  ::packet::Grid_Rect* _msg = _internal_mutable_triggerrectsecond();
  // @@protoc_insertion_point(field_mutable:packet.Grid_RigNPC.triggerRectSecond)
  return _msg;
}
inline void Grid_RigNPC::set_allocated_triggerrectsecond(::packet::Grid_Rect* triggerrectsecond) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete triggerrectsecond_;
  }
  if (triggerrectsecond) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(triggerrectsecond);
    if (message_arena != submessage_arena) {
      triggerrectsecond = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, triggerrectsecond, submessage_arena);
    }
    
  } else {
    
  }
  triggerrectsecond_ = triggerrectsecond;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_RigNPC.triggerRectSecond)
}

// -------------------------------------------------------------------

// Map_RigNPC

// repeated .packet.Grid_RigNPC vecGrids = 1;
inline int Map_RigNPC::_internal_vecgrids_size() const {
  return vecgrids_.size();
}
inline int Map_RigNPC::vecgrids_size() const {
  return _internal_vecgrids_size();
}
inline void Map_RigNPC::clear_vecgrids() {
  vecgrids_.Clear();
}
inline ::packet::Grid_RigNPC* Map_RigNPC::mutable_vecgrids(int index) {
  // @@protoc_insertion_point(field_mutable:packet.Map_RigNPC.vecGrids)
  return vecgrids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_RigNPC >*
Map_RigNPC::mutable_vecgrids() {
  // @@protoc_insertion_point(field_mutable_list:packet.Map_RigNPC.vecGrids)
  return &vecgrids_;
}
inline const ::packet::Grid_RigNPC& Map_RigNPC::_internal_vecgrids(int index) const {
  return vecgrids_.Get(index);
}
inline const ::packet::Grid_RigNPC& Map_RigNPC::vecgrids(int index) const {
  // @@protoc_insertion_point(field_get:packet.Map_RigNPC.vecGrids)
  return _internal_vecgrids(index);
}
inline ::packet::Grid_RigNPC* Map_RigNPC::_internal_add_vecgrids() {
  return vecgrids_.Add();
}
inline ::packet::Grid_RigNPC* Map_RigNPC::add_vecgrids() {
  ::packet::Grid_RigNPC* _add = _internal_add_vecgrids();
  // @@protoc_insertion_point(field_add:packet.Map_RigNPC.vecGrids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_RigNPC >&
Map_RigNPC::vecgrids() const {
  // @@protoc_insertion_point(field_list:packet.Map_RigNPC.vecGrids)
  return vecgrids_;
}

// -------------------------------------------------------------------

// Grid_Teleporter

// uint32 telType = 1;
inline void Grid_Teleporter::clear_teltype() {
  teltype_ = 0u;
}
inline uint32_t Grid_Teleporter::_internal_teltype() const {
  return teltype_;
}
inline uint32_t Grid_Teleporter::teltype() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Teleporter.telType)
  return _internal_teltype();
}
inline void Grid_Teleporter::_internal_set_teltype(uint32_t value) {
  
  teltype_ = value;
}
inline void Grid_Teleporter::set_teltype(uint32_t value) {
  _internal_set_teltype(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Teleporter.telType)
}

// uint32 targetMap = 2;
inline void Grid_Teleporter::clear_targetmap() {
  targetmap_ = 0u;
}
inline uint32_t Grid_Teleporter::_internal_targetmap() const {
  return targetmap_;
}
inline uint32_t Grid_Teleporter::targetmap() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Teleporter.targetMap)
  return _internal_targetmap();
}
inline void Grid_Teleporter::_internal_set_targetmap(uint32_t value) {
  
  targetmap_ = value;
}
inline void Grid_Teleporter::set_targetmap(uint32_t value) {
  _internal_set_targetmap(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Teleporter.targetMap)
}

// uint32 telAnim = 3;
inline void Grid_Teleporter::clear_telanim() {
  telanim_ = 0u;
}
inline uint32_t Grid_Teleporter::_internal_telanim() const {
  return telanim_;
}
inline uint32_t Grid_Teleporter::telanim() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Teleporter.telAnim)
  return _internal_telanim();
}
inline void Grid_Teleporter::_internal_set_telanim(uint32_t value) {
  
  telanim_ = value;
}
inline void Grid_Teleporter::set_telanim(uint32_t value) {
  _internal_set_telanim(value);
  // @@protoc_insertion_point(field_set:packet.Grid_Teleporter.telAnim)
}

// .packet.Grid_Rect triggerRect = 4;
inline bool Grid_Teleporter::_internal_has_triggerrect() const {
  return this != internal_default_instance() && triggerrect_ != nullptr;
}
inline bool Grid_Teleporter::has_triggerrect() const {
  return _internal_has_triggerrect();
}
inline void Grid_Teleporter::clear_triggerrect() {
  if (GetArenaForAllocation() == nullptr && triggerrect_ != nullptr) {
    delete triggerrect_;
  }
  triggerrect_ = nullptr;
}
inline const ::packet::Grid_Rect& Grid_Teleporter::_internal_triggerrect() const {
  const ::packet::Grid_Rect* p = triggerrect_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rect&>(
      ::packet::_Grid_Rect_default_instance_);
}
inline const ::packet::Grid_Rect& Grid_Teleporter::triggerrect() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Teleporter.triggerRect)
  return _internal_triggerrect();
}
inline void Grid_Teleporter::unsafe_arena_set_allocated_triggerrect(
    ::packet::Grid_Rect* triggerrect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(triggerrect_);
  }
  triggerrect_ = triggerrect;
  if (triggerrect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_Teleporter.triggerRect)
}
inline ::packet::Grid_Rect* Grid_Teleporter::release_triggerrect() {
  
  ::packet::Grid_Rect* temp = triggerrect_;
  triggerrect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rect* Grid_Teleporter::unsafe_arena_release_triggerrect() {
  // @@protoc_insertion_point(field_release:packet.Grid_Teleporter.triggerRect)
  
  ::packet::Grid_Rect* temp = triggerrect_;
  triggerrect_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rect* Grid_Teleporter::_internal_mutable_triggerrect() {
  
  if (triggerrect_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rect>(GetArenaForAllocation());
    triggerrect_ = p;
  }
  return triggerrect_;
}
inline ::packet::Grid_Rect* Grid_Teleporter::mutable_triggerrect() {
  ::packet::Grid_Rect* _msg = _internal_mutable_triggerrect();
  // @@protoc_insertion_point(field_mutable:packet.Grid_Teleporter.triggerRect)
  return _msg;
}
inline void Grid_Teleporter::set_allocated_triggerrect(::packet::Grid_Rect* triggerrect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete triggerrect_;
  }
  if (triggerrect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(triggerrect);
    if (message_arena != submessage_arena) {
      triggerrect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, triggerrect, submessage_arena);
    }
    
  } else {
    
  }
  triggerrect_ = triggerrect;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_Teleporter.triggerRect)
}

// .packet.Grid_Rotation rota = 5;
inline bool Grid_Teleporter::_internal_has_rota() const {
  return this != internal_default_instance() && rota_ != nullptr;
}
inline bool Grid_Teleporter::has_rota() const {
  return _internal_has_rota();
}
inline void Grid_Teleporter::clear_rota() {
  if (GetArenaForAllocation() == nullptr && rota_ != nullptr) {
    delete rota_;
  }
  rota_ = nullptr;
}
inline const ::packet::Grid_Rotation& Grid_Teleporter::_internal_rota() const {
  const ::packet::Grid_Rotation* p = rota_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rotation&>(
      ::packet::_Grid_Rotation_default_instance_);
}
inline const ::packet::Grid_Rotation& Grid_Teleporter::rota() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Teleporter.rota)
  return _internal_rota();
}
inline void Grid_Teleporter::unsafe_arena_set_allocated_rota(
    ::packet::Grid_Rotation* rota) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rota_);
  }
  rota_ = rota;
  if (rota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_Teleporter.rota)
}
inline ::packet::Grid_Rotation* Grid_Teleporter::release_rota() {
  
  ::packet::Grid_Rotation* temp = rota_;
  rota_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rotation* Grid_Teleporter::unsafe_arena_release_rota() {
  // @@protoc_insertion_point(field_release:packet.Grid_Teleporter.rota)
  
  ::packet::Grid_Rotation* temp = rota_;
  rota_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rotation* Grid_Teleporter::_internal_mutable_rota() {
  
  if (rota_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rotation>(GetArenaForAllocation());
    rota_ = p;
  }
  return rota_;
}
inline ::packet::Grid_Rotation* Grid_Teleporter::mutable_rota() {
  ::packet::Grid_Rotation* _msg = _internal_mutable_rota();
  // @@protoc_insertion_point(field_mutable:packet.Grid_Teleporter.rota)
  return _msg;
}
inline void Grid_Teleporter::set_allocated_rota(::packet::Grid_Rotation* rota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rota_;
  }
  if (rota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rota);
    if (message_arena != submessage_arena) {
      rota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rota, submessage_arena);
    }
    
  } else {
    
  }
  rota_ = rota;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_Teleporter.rota)
}

// .packet.Grid_Point pos = 6;
inline bool Grid_Teleporter::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool Grid_Teleporter::has_pos() const {
  return _internal_has_pos();
}
inline void Grid_Teleporter::clear_pos() {
  if (GetArenaForAllocation() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::packet::Grid_Point& Grid_Teleporter::_internal_pos() const {
  const ::packet::Grid_Point* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Point&>(
      ::packet::_Grid_Point_default_instance_);
}
inline const ::packet::Grid_Point& Grid_Teleporter::pos() const {
  // @@protoc_insertion_point(field_get:packet.Grid_Teleporter.pos)
  return _internal_pos();
}
inline void Grid_Teleporter::unsafe_arena_set_allocated_pos(
    ::packet::Grid_Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_Teleporter.pos)
}
inline ::packet::Grid_Point* Grid_Teleporter::release_pos() {
  
  ::packet::Grid_Point* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Point* Grid_Teleporter::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:packet.Grid_Teleporter.pos)
  
  ::packet::Grid_Point* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::packet::Grid_Point* Grid_Teleporter::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Point>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::packet::Grid_Point* Grid_Teleporter::mutable_pos() {
  ::packet::Grid_Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:packet.Grid_Teleporter.pos)
  return _msg;
}
inline void Grid_Teleporter::set_allocated_pos(::packet::Grid_Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_Teleporter.pos)
}

// -------------------------------------------------------------------

// Map_Teleporter

// repeated .packet.Grid_Teleporter vecGrids = 1;
inline int Map_Teleporter::_internal_vecgrids_size() const {
  return vecgrids_.size();
}
inline int Map_Teleporter::vecgrids_size() const {
  return _internal_vecgrids_size();
}
inline void Map_Teleporter::clear_vecgrids() {
  vecgrids_.Clear();
}
inline ::packet::Grid_Teleporter* Map_Teleporter::mutable_vecgrids(int index) {
  // @@protoc_insertion_point(field_mutable:packet.Map_Teleporter.vecGrids)
  return vecgrids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_Teleporter >*
Map_Teleporter::mutable_vecgrids() {
  // @@protoc_insertion_point(field_mutable_list:packet.Map_Teleporter.vecGrids)
  return &vecgrids_;
}
inline const ::packet::Grid_Teleporter& Map_Teleporter::_internal_vecgrids(int index) const {
  return vecgrids_.Get(index);
}
inline const ::packet::Grid_Teleporter& Map_Teleporter::vecgrids(int index) const {
  // @@protoc_insertion_point(field_get:packet.Map_Teleporter.vecGrids)
  return _internal_vecgrids(index);
}
inline ::packet::Grid_Teleporter* Map_Teleporter::_internal_add_vecgrids() {
  return vecgrids_.Add();
}
inline ::packet::Grid_Teleporter* Map_Teleporter::add_vecgrids() {
  ::packet::Grid_Teleporter* _add = _internal_add_vecgrids();
  // @@protoc_insertion_point(field_add:packet.Map_Teleporter.vecGrids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_Teleporter >&
Map_Teleporter::vecgrids() const {
  // @@protoc_insertion_point(field_list:packet.Map_Teleporter.vecGrids)
  return vecgrids_;
}

// -------------------------------------------------------------------

// Grid_BlockArea

// uint32 blockAreaId = 1;
inline void Grid_BlockArea::clear_blockareaid() {
  blockareaid_ = 0u;
}
inline uint32_t Grid_BlockArea::_internal_blockareaid() const {
  return blockareaid_;
}
inline uint32_t Grid_BlockArea::blockareaid() const {
  // @@protoc_insertion_point(field_get:packet.Grid_BlockArea.blockAreaId)
  return _internal_blockareaid();
}
inline void Grid_BlockArea::_internal_set_blockareaid(uint32_t value) {
  
  blockareaid_ = value;
}
inline void Grid_BlockArea::set_blockareaid(uint32_t value) {
  _internal_set_blockareaid(value);
  // @@protoc_insertion_point(field_set:packet.Grid_BlockArea.blockAreaId)
}

// .packet.Grid_Rect blockRect = 2;
inline bool Grid_BlockArea::_internal_has_blockrect() const {
  return this != internal_default_instance() && blockrect_ != nullptr;
}
inline bool Grid_BlockArea::has_blockrect() const {
  return _internal_has_blockrect();
}
inline void Grid_BlockArea::clear_blockrect() {
  if (GetArenaForAllocation() == nullptr && blockrect_ != nullptr) {
    delete blockrect_;
  }
  blockrect_ = nullptr;
}
inline const ::packet::Grid_Rect& Grid_BlockArea::_internal_blockrect() const {
  const ::packet::Grid_Rect* p = blockrect_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rect&>(
      ::packet::_Grid_Rect_default_instance_);
}
inline const ::packet::Grid_Rect& Grid_BlockArea::blockrect() const {
  // @@protoc_insertion_point(field_get:packet.Grid_BlockArea.blockRect)
  return _internal_blockrect();
}
inline void Grid_BlockArea::unsafe_arena_set_allocated_blockrect(
    ::packet::Grid_Rect* blockrect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blockrect_);
  }
  blockrect_ = blockrect;
  if (blockrect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_BlockArea.blockRect)
}
inline ::packet::Grid_Rect* Grid_BlockArea::release_blockrect() {
  
  ::packet::Grid_Rect* temp = blockrect_;
  blockrect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rect* Grid_BlockArea::unsafe_arena_release_blockrect() {
  // @@protoc_insertion_point(field_release:packet.Grid_BlockArea.blockRect)
  
  ::packet::Grid_Rect* temp = blockrect_;
  blockrect_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rect* Grid_BlockArea::_internal_mutable_blockrect() {
  
  if (blockrect_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rect>(GetArenaForAllocation());
    blockrect_ = p;
  }
  return blockrect_;
}
inline ::packet::Grid_Rect* Grid_BlockArea::mutable_blockrect() {
  ::packet::Grid_Rect* _msg = _internal_mutable_blockrect();
  // @@protoc_insertion_point(field_mutable:packet.Grid_BlockArea.blockRect)
  return _msg;
}
inline void Grid_BlockArea::set_allocated_blockrect(::packet::Grid_Rect* blockrect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete blockrect_;
  }
  if (blockrect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(blockrect);
    if (message_arena != submessage_arena) {
      blockrect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blockrect, submessage_arena);
    }
    
  } else {
    
  }
  blockrect_ = blockrect;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_BlockArea.blockRect)
}

// uint64 instanceId = 3;
inline void Grid_BlockArea::clear_instanceid() {
  instanceid_ = uint64_t{0u};
}
inline uint64_t Grid_BlockArea::_internal_instanceid() const {
  return instanceid_;
}
inline uint64_t Grid_BlockArea::instanceid() const {
  // @@protoc_insertion_point(field_get:packet.Grid_BlockArea.instanceId)
  return _internal_instanceid();
}
inline void Grid_BlockArea::_internal_set_instanceid(uint64_t value) {
  
  instanceid_ = value;
}
inline void Grid_BlockArea::set_instanceid(uint64_t value) {
  _internal_set_instanceid(value);
  // @@protoc_insertion_point(field_set:packet.Grid_BlockArea.instanceId)
}

// -------------------------------------------------------------------

// Map_BlockArea

// repeated .packet.Grid_BlockArea vecGrids = 1;
inline int Map_BlockArea::_internal_vecgrids_size() const {
  return vecgrids_.size();
}
inline int Map_BlockArea::vecgrids_size() const {
  return _internal_vecgrids_size();
}
inline void Map_BlockArea::clear_vecgrids() {
  vecgrids_.Clear();
}
inline ::packet::Grid_BlockArea* Map_BlockArea::mutable_vecgrids(int index) {
  // @@protoc_insertion_point(field_mutable:packet.Map_BlockArea.vecGrids)
  return vecgrids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_BlockArea >*
Map_BlockArea::mutable_vecgrids() {
  // @@protoc_insertion_point(field_mutable_list:packet.Map_BlockArea.vecGrids)
  return &vecgrids_;
}
inline const ::packet::Grid_BlockArea& Map_BlockArea::_internal_vecgrids(int index) const {
  return vecgrids_.Get(index);
}
inline const ::packet::Grid_BlockArea& Map_BlockArea::vecgrids(int index) const {
  // @@protoc_insertion_point(field_get:packet.Map_BlockArea.vecGrids)
  return _internal_vecgrids(index);
}
inline ::packet::Grid_BlockArea* Map_BlockArea::_internal_add_vecgrids() {
  return vecgrids_.Add();
}
inline ::packet::Grid_BlockArea* Map_BlockArea::add_vecgrids() {
  ::packet::Grid_BlockArea* _add = _internal_add_vecgrids();
  // @@protoc_insertion_point(field_add:packet.Map_BlockArea.vecGrids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_BlockArea >&
Map_BlockArea::vecgrids() const {
  // @@protoc_insertion_point(field_list:packet.Map_BlockArea.vecGrids)
  return vecgrids_;
}

// -------------------------------------------------------------------

// Grid_MonsterGroup_Grid_MonsterGroupUnit

// uint32 monsterGroupId = 1;
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::clear_monstergroupid() {
  monstergroupid_ = 0u;
}
inline uint32_t Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_monstergroupid() const {
  return monstergroupid_;
}
inline uint32_t Grid_MonsterGroup_Grid_MonsterGroupUnit::monstergroupid() const {
  // @@protoc_insertion_point(field_get:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.monsterGroupId)
  return _internal_monstergroupid();
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_set_monstergroupid(uint32_t value) {
  
  monstergroupid_ = value;
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::set_monstergroupid(uint32_t value) {
  _internal_set_monstergroupid(value);
  // @@protoc_insertion_point(field_set:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.monsterGroupId)
}

// .packet.Grid_Rect createRect = 2;
inline bool Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_has_createrect() const {
  return this != internal_default_instance() && createrect_ != nullptr;
}
inline bool Grid_MonsterGroup_Grid_MonsterGroupUnit::has_createrect() const {
  return _internal_has_createrect();
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::clear_createrect() {
  if (GetArenaForAllocation() == nullptr && createrect_ != nullptr) {
    delete createrect_;
  }
  createrect_ = nullptr;
}
inline const ::packet::Grid_Rect& Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_createrect() const {
  const ::packet::Grid_Rect* p = createrect_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rect&>(
      ::packet::_Grid_Rect_default_instance_);
}
inline const ::packet::Grid_Rect& Grid_MonsterGroup_Grid_MonsterGroupUnit::createrect() const {
  // @@protoc_insertion_point(field_get:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.createRect)
  return _internal_createrect();
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::unsafe_arena_set_allocated_createrect(
    ::packet::Grid_Rect* createrect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(createrect_);
  }
  createrect_ = createrect;
  if (createrect) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.createRect)
}
inline ::packet::Grid_Rect* Grid_MonsterGroup_Grid_MonsterGroupUnit::release_createrect() {
  
  ::packet::Grid_Rect* temp = createrect_;
  createrect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rect* Grid_MonsterGroup_Grid_MonsterGroupUnit::unsafe_arena_release_createrect() {
  // @@protoc_insertion_point(field_release:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.createRect)
  
  ::packet::Grid_Rect* temp = createrect_;
  createrect_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rect* Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_mutable_createrect() {
  
  if (createrect_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rect>(GetArenaForAllocation());
    createrect_ = p;
  }
  return createrect_;
}
inline ::packet::Grid_Rect* Grid_MonsterGroup_Grid_MonsterGroupUnit::mutable_createrect() {
  ::packet::Grid_Rect* _msg = _internal_mutable_createrect();
  // @@protoc_insertion_point(field_mutable:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.createRect)
  return _msg;
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::set_allocated_createrect(::packet::Grid_Rect* createrect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete createrect_;
  }
  if (createrect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(createrect);
    if (message_arena != submessage_arena) {
      createrect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createrect, submessage_arena);
    }
    
  } else {
    
  }
  createrect_ = createrect;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.createRect)
}

// .packet.Grid_Rotation rota = 3;
inline bool Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_has_rota() const {
  return this != internal_default_instance() && rota_ != nullptr;
}
inline bool Grid_MonsterGroup_Grid_MonsterGroupUnit::has_rota() const {
  return _internal_has_rota();
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::clear_rota() {
  if (GetArenaForAllocation() == nullptr && rota_ != nullptr) {
    delete rota_;
  }
  rota_ = nullptr;
}
inline const ::packet::Grid_Rotation& Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_rota() const {
  const ::packet::Grid_Rotation* p = rota_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Rotation&>(
      ::packet::_Grid_Rotation_default_instance_);
}
inline const ::packet::Grid_Rotation& Grid_MonsterGroup_Grid_MonsterGroupUnit::rota() const {
  // @@protoc_insertion_point(field_get:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.rota)
  return _internal_rota();
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::unsafe_arena_set_allocated_rota(
    ::packet::Grid_Rotation* rota) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rota_);
  }
  rota_ = rota;
  if (rota) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.rota)
}
inline ::packet::Grid_Rotation* Grid_MonsterGroup_Grid_MonsterGroupUnit::release_rota() {
  
  ::packet::Grid_Rotation* temp = rota_;
  rota_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Rotation* Grid_MonsterGroup_Grid_MonsterGroupUnit::unsafe_arena_release_rota() {
  // @@protoc_insertion_point(field_release:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.rota)
  
  ::packet::Grid_Rotation* temp = rota_;
  rota_ = nullptr;
  return temp;
}
inline ::packet::Grid_Rotation* Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_mutable_rota() {
  
  if (rota_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Rotation>(GetArenaForAllocation());
    rota_ = p;
  }
  return rota_;
}
inline ::packet::Grid_Rotation* Grid_MonsterGroup_Grid_MonsterGroupUnit::mutable_rota() {
  ::packet::Grid_Rotation* _msg = _internal_mutable_rota();
  // @@protoc_insertion_point(field_mutable:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.rota)
  return _msg;
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::set_allocated_rota(::packet::Grid_Rotation* rota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rota_;
  }
  if (rota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rota);
    if (message_arena != submessage_arena) {
      rota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rota, submessage_arena);
    }
    
  } else {
    
  }
  rota_ = rota;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.rota)
}

// .packet.Grid_Point pos = 4;
inline bool Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool Grid_MonsterGroup_Grid_MonsterGroupUnit::has_pos() const {
  return _internal_has_pos();
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::clear_pos() {
  if (GetArenaForAllocation() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::packet::Grid_Point& Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_pos() const {
  const ::packet::Grid_Point* p = pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Grid_Point&>(
      ::packet::_Grid_Point_default_instance_);
}
inline const ::packet::Grid_Point& Grid_MonsterGroup_Grid_MonsterGroupUnit::pos() const {
  // @@protoc_insertion_point(field_get:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.pos)
  return _internal_pos();
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::unsafe_arena_set_allocated_pos(
    ::packet::Grid_Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.pos)
}
inline ::packet::Grid_Point* Grid_MonsterGroup_Grid_MonsterGroupUnit::release_pos() {
  
  ::packet::Grid_Point* temp = pos_;
  pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Grid_Point* Grid_MonsterGroup_Grid_MonsterGroupUnit::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.pos)
  
  ::packet::Grid_Point* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::packet::Grid_Point* Grid_MonsterGroup_Grid_MonsterGroupUnit::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Grid_Point>(GetArenaForAllocation());
    pos_ = p;
  }
  return pos_;
}
inline ::packet::Grid_Point* Grid_MonsterGroup_Grid_MonsterGroupUnit::mutable_pos() {
  ::packet::Grid_Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.pos)
  return _msg;
}
inline void Grid_MonsterGroup_Grid_MonsterGroupUnit::set_allocated_pos(::packet::Grid_Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:packet.Grid_MonsterGroup.Grid_MonsterGroupUnit.pos)
}

// -------------------------------------------------------------------

// Grid_MonsterGroup

// repeated .packet.Grid_MonsterGroup.Grid_MonsterGroupUnit vecGroups = 1;
inline int Grid_MonsterGroup::_internal_vecgroups_size() const {
  return vecgroups_.size();
}
inline int Grid_MonsterGroup::vecgroups_size() const {
  return _internal_vecgroups_size();
}
inline void Grid_MonsterGroup::clear_vecgroups() {
  vecgroups_.Clear();
}
inline ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* Grid_MonsterGroup::mutable_vecgroups(int index) {
  // @@protoc_insertion_point(field_mutable:packet.Grid_MonsterGroup.vecGroups)
  return vecgroups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit >*
Grid_MonsterGroup::mutable_vecgroups() {
  // @@protoc_insertion_point(field_mutable_list:packet.Grid_MonsterGroup.vecGroups)
  return &vecgroups_;
}
inline const ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit& Grid_MonsterGroup::_internal_vecgroups(int index) const {
  return vecgroups_.Get(index);
}
inline const ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit& Grid_MonsterGroup::vecgroups(int index) const {
  // @@protoc_insertion_point(field_get:packet.Grid_MonsterGroup.vecGroups)
  return _internal_vecgroups(index);
}
inline ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* Grid_MonsterGroup::_internal_add_vecgroups() {
  return vecgroups_.Add();
}
inline ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* Grid_MonsterGroup::add_vecgroups() {
  ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit* _add = _internal_add_vecgroups();
  // @@protoc_insertion_point(field_add:packet.Grid_MonsterGroup.vecGroups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup_Grid_MonsterGroupUnit >&
Grid_MonsterGroup::vecgroups() const {
  // @@protoc_insertion_point(field_list:packet.Grid_MonsterGroup.vecGroups)
  return vecgroups_;
}

// -------------------------------------------------------------------

// Map_MonsterGroup

// repeated .packet.Grid_MonsterGroup vecGrids = 1;
inline int Map_MonsterGroup::_internal_vecgrids_size() const {
  return vecgrids_.size();
}
inline int Map_MonsterGroup::vecgrids_size() const {
  return _internal_vecgrids_size();
}
inline void Map_MonsterGroup::clear_vecgrids() {
  vecgrids_.Clear();
}
inline ::packet::Grid_MonsterGroup* Map_MonsterGroup::mutable_vecgrids(int index) {
  // @@protoc_insertion_point(field_mutable:packet.Map_MonsterGroup.vecGrids)
  return vecgrids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup >*
Map_MonsterGroup::mutable_vecgrids() {
  // @@protoc_insertion_point(field_mutable_list:packet.Map_MonsterGroup.vecGrids)
  return &vecgrids_;
}
inline const ::packet::Grid_MonsterGroup& Map_MonsterGroup::_internal_vecgrids(int index) const {
  return vecgrids_.Get(index);
}
inline const ::packet::Grid_MonsterGroup& Map_MonsterGroup::vecgrids(int index) const {
  // @@protoc_insertion_point(field_get:packet.Map_MonsterGroup.vecGrids)
  return _internal_vecgrids(index);
}
inline ::packet::Grid_MonsterGroup* Map_MonsterGroup::_internal_add_vecgrids() {
  return vecgrids_.Add();
}
inline ::packet::Grid_MonsterGroup* Map_MonsterGroup::add_vecgrids() {
  ::packet::Grid_MonsterGroup* _add = _internal_add_vecgrids();
  // @@protoc_insertion_point(field_add:packet.Map_MonsterGroup.vecGrids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::packet::Grid_MonsterGroup >&
Map_MonsterGroup::vecgrids() const {
  // @@protoc_insertion_point(field_list:packet.Map_MonsterGroup.vecGrids)
  return vecgrids_;
}

// -------------------------------------------------------------------

// Map_Info

// uint32 width = 1;
inline void Map_Info::clear_width() {
  width_ = 0u;
}
inline uint32_t Map_Info::_internal_width() const {
  return width_;
}
inline uint32_t Map_Info::width() const {
  // @@protoc_insertion_point(field_get:packet.Map_Info.width)
  return _internal_width();
}
inline void Map_Info::_internal_set_width(uint32_t value) {
  
  width_ = value;
}
inline void Map_Info::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:packet.Map_Info.width)
}

// uint32 height = 2;
inline void Map_Info::clear_height() {
  height_ = 0u;
}
inline uint32_t Map_Info::_internal_height() const {
  return height_;
}
inline uint32_t Map_Info::height() const {
  // @@protoc_insertion_point(field_get:packet.Map_Info.height)
  return _internal_height();
}
inline void Map_Info::_internal_set_height(uint32_t value) {
  
  height_ = value;
}
inline void Map_Info::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:packet.Map_Info.height)
}

// -------------------------------------------------------------------

// Map_AllTypes

// .packet.BrushType type = 1;
inline void Map_AllTypes::clear_type() {
  type_ = 0;
}
inline ::packet::BrushType Map_AllTypes::_internal_type() const {
  return static_cast< ::packet::BrushType >(type_);
}
inline ::packet::BrushType Map_AllTypes::type() const {
  // @@protoc_insertion_point(field_get:packet.Map_AllTypes.type)
  return _internal_type();
}
inline void Map_AllTypes::_internal_set_type(::packet::BrushType value) {
  
  type_ = value;
}
inline void Map_AllTypes::set_type(::packet::BrushType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:packet.Map_AllTypes.type)
}

// .packet.Map_RigNPC mapRigNPC = 2;
inline bool Map_AllTypes::_internal_has_maprignpc() const {
  return this != internal_default_instance() && maprignpc_ != nullptr;
}
inline bool Map_AllTypes::has_maprignpc() const {
  return _internal_has_maprignpc();
}
inline void Map_AllTypes::clear_maprignpc() {
  if (GetArenaForAllocation() == nullptr && maprignpc_ != nullptr) {
    delete maprignpc_;
  }
  maprignpc_ = nullptr;
}
inline const ::packet::Map_RigNPC& Map_AllTypes::_internal_maprignpc() const {
  const ::packet::Map_RigNPC* p = maprignpc_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Map_RigNPC&>(
      ::packet::_Map_RigNPC_default_instance_);
}
inline const ::packet::Map_RigNPC& Map_AllTypes::maprignpc() const {
  // @@protoc_insertion_point(field_get:packet.Map_AllTypes.mapRigNPC)
  return _internal_maprignpc();
}
inline void Map_AllTypes::unsafe_arena_set_allocated_maprignpc(
    ::packet::Map_RigNPC* maprignpc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maprignpc_);
  }
  maprignpc_ = maprignpc;
  if (maprignpc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Map_AllTypes.mapRigNPC)
}
inline ::packet::Map_RigNPC* Map_AllTypes::release_maprignpc() {
  
  ::packet::Map_RigNPC* temp = maprignpc_;
  maprignpc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Map_RigNPC* Map_AllTypes::unsafe_arena_release_maprignpc() {
  // @@protoc_insertion_point(field_release:packet.Map_AllTypes.mapRigNPC)
  
  ::packet::Map_RigNPC* temp = maprignpc_;
  maprignpc_ = nullptr;
  return temp;
}
inline ::packet::Map_RigNPC* Map_AllTypes::_internal_mutable_maprignpc() {
  
  if (maprignpc_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Map_RigNPC>(GetArenaForAllocation());
    maprignpc_ = p;
  }
  return maprignpc_;
}
inline ::packet::Map_RigNPC* Map_AllTypes::mutable_maprignpc() {
  ::packet::Map_RigNPC* _msg = _internal_mutable_maprignpc();
  // @@protoc_insertion_point(field_mutable:packet.Map_AllTypes.mapRigNPC)
  return _msg;
}
inline void Map_AllTypes::set_allocated_maprignpc(::packet::Map_RigNPC* maprignpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete maprignpc_;
  }
  if (maprignpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maprignpc);
    if (message_arena != submessage_arena) {
      maprignpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maprignpc, submessage_arena);
    }
    
  } else {
    
  }
  maprignpc_ = maprignpc;
  // @@protoc_insertion_point(field_set_allocated:packet.Map_AllTypes.mapRigNPC)
}

// .packet.Map_Teleporter mapTel = 3;
inline bool Map_AllTypes::_internal_has_maptel() const {
  return this != internal_default_instance() && maptel_ != nullptr;
}
inline bool Map_AllTypes::has_maptel() const {
  return _internal_has_maptel();
}
inline void Map_AllTypes::clear_maptel() {
  if (GetArenaForAllocation() == nullptr && maptel_ != nullptr) {
    delete maptel_;
  }
  maptel_ = nullptr;
}
inline const ::packet::Map_Teleporter& Map_AllTypes::_internal_maptel() const {
  const ::packet::Map_Teleporter* p = maptel_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Map_Teleporter&>(
      ::packet::_Map_Teleporter_default_instance_);
}
inline const ::packet::Map_Teleporter& Map_AllTypes::maptel() const {
  // @@protoc_insertion_point(field_get:packet.Map_AllTypes.mapTel)
  return _internal_maptel();
}
inline void Map_AllTypes::unsafe_arena_set_allocated_maptel(
    ::packet::Map_Teleporter* maptel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maptel_);
  }
  maptel_ = maptel;
  if (maptel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Map_AllTypes.mapTel)
}
inline ::packet::Map_Teleporter* Map_AllTypes::release_maptel() {
  
  ::packet::Map_Teleporter* temp = maptel_;
  maptel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Map_Teleporter* Map_AllTypes::unsafe_arena_release_maptel() {
  // @@protoc_insertion_point(field_release:packet.Map_AllTypes.mapTel)
  
  ::packet::Map_Teleporter* temp = maptel_;
  maptel_ = nullptr;
  return temp;
}
inline ::packet::Map_Teleporter* Map_AllTypes::_internal_mutable_maptel() {
  
  if (maptel_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Map_Teleporter>(GetArenaForAllocation());
    maptel_ = p;
  }
  return maptel_;
}
inline ::packet::Map_Teleporter* Map_AllTypes::mutable_maptel() {
  ::packet::Map_Teleporter* _msg = _internal_mutable_maptel();
  // @@protoc_insertion_point(field_mutable:packet.Map_AllTypes.mapTel)
  return _msg;
}
inline void Map_AllTypes::set_allocated_maptel(::packet::Map_Teleporter* maptel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete maptel_;
  }
  if (maptel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maptel);
    if (message_arena != submessage_arena) {
      maptel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maptel, submessage_arena);
    }
    
  } else {
    
  }
  maptel_ = maptel;
  // @@protoc_insertion_point(field_set_allocated:packet.Map_AllTypes.mapTel)
}

// .packet.Map_BlockArea mapBlock = 4;
inline bool Map_AllTypes::_internal_has_mapblock() const {
  return this != internal_default_instance() && mapblock_ != nullptr;
}
inline bool Map_AllTypes::has_mapblock() const {
  return _internal_has_mapblock();
}
inline void Map_AllTypes::clear_mapblock() {
  if (GetArenaForAllocation() == nullptr && mapblock_ != nullptr) {
    delete mapblock_;
  }
  mapblock_ = nullptr;
}
inline const ::packet::Map_BlockArea& Map_AllTypes::_internal_mapblock() const {
  const ::packet::Map_BlockArea* p = mapblock_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Map_BlockArea&>(
      ::packet::_Map_BlockArea_default_instance_);
}
inline const ::packet::Map_BlockArea& Map_AllTypes::mapblock() const {
  // @@protoc_insertion_point(field_get:packet.Map_AllTypes.mapBlock)
  return _internal_mapblock();
}
inline void Map_AllTypes::unsafe_arena_set_allocated_mapblock(
    ::packet::Map_BlockArea* mapblock) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapblock_);
  }
  mapblock_ = mapblock;
  if (mapblock) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Map_AllTypes.mapBlock)
}
inline ::packet::Map_BlockArea* Map_AllTypes::release_mapblock() {
  
  ::packet::Map_BlockArea* temp = mapblock_;
  mapblock_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Map_BlockArea* Map_AllTypes::unsafe_arena_release_mapblock() {
  // @@protoc_insertion_point(field_release:packet.Map_AllTypes.mapBlock)
  
  ::packet::Map_BlockArea* temp = mapblock_;
  mapblock_ = nullptr;
  return temp;
}
inline ::packet::Map_BlockArea* Map_AllTypes::_internal_mutable_mapblock() {
  
  if (mapblock_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Map_BlockArea>(GetArenaForAllocation());
    mapblock_ = p;
  }
  return mapblock_;
}
inline ::packet::Map_BlockArea* Map_AllTypes::mutable_mapblock() {
  ::packet::Map_BlockArea* _msg = _internal_mutable_mapblock();
  // @@protoc_insertion_point(field_mutable:packet.Map_AllTypes.mapBlock)
  return _msg;
}
inline void Map_AllTypes::set_allocated_mapblock(::packet::Map_BlockArea* mapblock) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mapblock_;
  }
  if (mapblock) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mapblock);
    if (message_arena != submessage_arena) {
      mapblock = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapblock, submessage_arena);
    }
    
  } else {
    
  }
  mapblock_ = mapblock;
  // @@protoc_insertion_point(field_set_allocated:packet.Map_AllTypes.mapBlock)
}

// .packet.Map_MonsterGroup mapMonsterGroup = 5;
inline bool Map_AllTypes::_internal_has_mapmonstergroup() const {
  return this != internal_default_instance() && mapmonstergroup_ != nullptr;
}
inline bool Map_AllTypes::has_mapmonstergroup() const {
  return _internal_has_mapmonstergroup();
}
inline void Map_AllTypes::clear_mapmonstergroup() {
  if (GetArenaForAllocation() == nullptr && mapmonstergroup_ != nullptr) {
    delete mapmonstergroup_;
  }
  mapmonstergroup_ = nullptr;
}
inline const ::packet::Map_MonsterGroup& Map_AllTypes::_internal_mapmonstergroup() const {
  const ::packet::Map_MonsterGroup* p = mapmonstergroup_;
  return p != nullptr ? *p : reinterpret_cast<const ::packet::Map_MonsterGroup&>(
      ::packet::_Map_MonsterGroup_default_instance_);
}
inline const ::packet::Map_MonsterGroup& Map_AllTypes::mapmonstergroup() const {
  // @@protoc_insertion_point(field_get:packet.Map_AllTypes.mapMonsterGroup)
  return _internal_mapmonstergroup();
}
inline void Map_AllTypes::unsafe_arena_set_allocated_mapmonstergroup(
    ::packet::Map_MonsterGroup* mapmonstergroup) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mapmonstergroup_);
  }
  mapmonstergroup_ = mapmonstergroup;
  if (mapmonstergroup) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:packet.Map_AllTypes.mapMonsterGroup)
}
inline ::packet::Map_MonsterGroup* Map_AllTypes::release_mapmonstergroup() {
  
  ::packet::Map_MonsterGroup* temp = mapmonstergroup_;
  mapmonstergroup_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::packet::Map_MonsterGroup* Map_AllTypes::unsafe_arena_release_mapmonstergroup() {
  // @@protoc_insertion_point(field_release:packet.Map_AllTypes.mapMonsterGroup)
  
  ::packet::Map_MonsterGroup* temp = mapmonstergroup_;
  mapmonstergroup_ = nullptr;
  return temp;
}
inline ::packet::Map_MonsterGroup* Map_AllTypes::_internal_mutable_mapmonstergroup() {
  
  if (mapmonstergroup_ == nullptr) {
    auto* p = CreateMaybeMessage<::packet::Map_MonsterGroup>(GetArenaForAllocation());
    mapmonstergroup_ = p;
  }
  return mapmonstergroup_;
}
inline ::packet::Map_MonsterGroup* Map_AllTypes::mutable_mapmonstergroup() {
  ::packet::Map_MonsterGroup* _msg = _internal_mutable_mapmonstergroup();
  // @@protoc_insertion_point(field_mutable:packet.Map_AllTypes.mapMonsterGroup)
  return _msg;
}
inline void Map_AllTypes::set_allocated_mapmonstergroup(::packet::Map_MonsterGroup* mapmonstergroup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mapmonstergroup_;
  }
  if (mapmonstergroup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mapmonstergroup);
    if (message_arena != submessage_arena) {
      mapmonstergroup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mapmonstergroup, submessage_arena);
    }
    
  } else {
    
  }
  mapmonstergroup_ = mapmonstergroup;
  // @@protoc_insertion_point(field_set_allocated:packet.Map_AllTypes.mapMonsterGroup)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace packet

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::packet::BrushType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::packet::BrushType>() {
  return ::packet::BrushType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_5fcfg_5fins_2eproto
