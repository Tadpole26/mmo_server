// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: innerteam.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_innerteam_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_innerteam_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_innerteam_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_innerteam_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_innerteam_2eproto;
namespace inner {
class InnerTeam;
struct InnerTeamDefaultTypeInternal;
extern InnerTeamDefaultTypeInternal _InnerTeam_default_instance_;
class InnerTeamBase;
struct InnerTeamBaseDefaultTypeInternal;
extern InnerTeamBaseDefaultTypeInternal _InnerTeamBase_default_instance_;
class InnerTeamField;
struct InnerTeamFieldDefaultTypeInternal;
extern InnerTeamFieldDefaultTypeInternal _InnerTeamField_default_instance_;
class InnerTeamList;
struct InnerTeamListDefaultTypeInternal;
extern InnerTeamListDefaultTypeInternal _InnerTeamList_default_instance_;
class InnerTeamMember;
struct InnerTeamMemberDefaultTypeInternal;
extern InnerTeamMemberDefaultTypeInternal _InnerTeamMember_default_instance_;
class InnerTeamMemberField;
struct InnerTeamMemberFieldDefaultTypeInternal;
extern InnerTeamMemberFieldDefaultTypeInternal _InnerTeamMemberField_default_instance_;
class InnerTeam_MlistEntry_DoNotUse;
struct InnerTeam_MlistEntry_DoNotUseDefaultTypeInternal;
extern InnerTeam_MlistEntry_DoNotUseDefaultTypeInternal _InnerTeam_MlistEntry_DoNotUse_default_instance_;
}  // namespace inner
PROTOBUF_NAMESPACE_OPEN
template<> ::inner::InnerTeam* Arena::CreateMaybeMessage<::inner::InnerTeam>(Arena*);
template<> ::inner::InnerTeamBase* Arena::CreateMaybeMessage<::inner::InnerTeamBase>(Arena*);
template<> ::inner::InnerTeamField* Arena::CreateMaybeMessage<::inner::InnerTeamField>(Arena*);
template<> ::inner::InnerTeamList* Arena::CreateMaybeMessage<::inner::InnerTeamList>(Arena*);
template<> ::inner::InnerTeamMember* Arena::CreateMaybeMessage<::inner::InnerTeamMember>(Arena*);
template<> ::inner::InnerTeamMemberField* Arena::CreateMaybeMessage<::inner::InnerTeamMemberField>(Arena*);
template<> ::inner::InnerTeam_MlistEntry_DoNotUse* Arena::CreateMaybeMessage<::inner::InnerTeam_MlistEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace inner {

enum InnerTeamFieldType : int {
  TFType_None = 0,
  TFType_LeaderId = 1,
  TFType_TargetId = 2,
  TFType_MinLevel = 3,
  TFType_MaxLevel = 4,
  TFType_MatchTime = 5,
  TFType_Text = 6,
  TFType_MidwayJoin = 7,
  InnerTeamFieldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InnerTeamFieldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InnerTeamFieldType_IsValid(int value);
constexpr InnerTeamFieldType InnerTeamFieldType_MIN = TFType_None;
constexpr InnerTeamFieldType InnerTeamFieldType_MAX = TFType_MidwayJoin;
constexpr int InnerTeamFieldType_ARRAYSIZE = InnerTeamFieldType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InnerTeamFieldType_descriptor();
template<typename T>
inline const std::string& InnerTeamFieldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InnerTeamFieldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InnerTeamFieldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InnerTeamFieldType_descriptor(), enum_t_value);
}
inline bool InnerTeamFieldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InnerTeamFieldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InnerTeamFieldType>(
    InnerTeamFieldType_descriptor(), name, value);
}
enum InnerTeamMemberFieldType : int {
  TMFType_None = 0,
  TMFType_Index = 1,
  TMFType_State = 2,
  TMFType_Follow = 3,
  TMFType_SceneId = 4,
  InnerTeamMemberFieldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InnerTeamMemberFieldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InnerTeamMemberFieldType_IsValid(int value);
constexpr InnerTeamMemberFieldType InnerTeamMemberFieldType_MIN = TMFType_None;
constexpr InnerTeamMemberFieldType InnerTeamMemberFieldType_MAX = TMFType_SceneId;
constexpr int InnerTeamMemberFieldType_ARRAYSIZE = InnerTeamMemberFieldType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InnerTeamMemberFieldType_descriptor();
template<typename T>
inline const std::string& InnerTeamMemberFieldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InnerTeamMemberFieldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InnerTeamMemberFieldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InnerTeamMemberFieldType_descriptor(), enum_t_value);
}
inline bool InnerTeamMemberFieldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InnerTeamMemberFieldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InnerTeamMemberFieldType>(
    InnerTeamMemberFieldType_descriptor(), name, value);
}
// ===================================================================

class InnerTeamList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inner.InnerTeamList) */ {
 public:
  inline InnerTeamList() : InnerTeamList(nullptr) {}
  ~InnerTeamList() override;
  explicit PROTOBUF_CONSTEXPR InnerTeamList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerTeamList(const InnerTeamList& from);
  InnerTeamList(InnerTeamList&& from) noexcept
    : InnerTeamList() {
    *this = ::std::move(from);
  }

  inline InnerTeamList& operator=(const InnerTeamList& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerTeamList& operator=(InnerTeamList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerTeamList& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerTeamList* internal_default_instance() {
    return reinterpret_cast<const InnerTeamList*>(
               &_InnerTeamList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InnerTeamList& a, InnerTeamList& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerTeamList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerTeamList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerTeamList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerTeamList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerTeamList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InnerTeamList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerTeamList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inner.InnerTeamList";
  }
  protected:
  explicit InnerTeamList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTeamsFieldNumber = 1,
  };
  // repeated .inner.InnerTeam teams = 1;
  int teams_size() const;
  private:
  int _internal_teams_size() const;
  public:
  void clear_teams();
  ::inner::InnerTeam* mutable_teams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inner::InnerTeam >*
      mutable_teams();
  private:
  const ::inner::InnerTeam& _internal_teams(int index) const;
  ::inner::InnerTeam* _internal_add_teams();
  public:
  const ::inner::InnerTeam& teams(int index) const;
  ::inner::InnerTeam* add_teams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inner::InnerTeam >&
      teams() const;

  // @@protoc_insertion_point(class_scope:inner.InnerTeamList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inner::InnerTeam > teams_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_innerteam_2eproto;
};
// -------------------------------------------------------------------

class InnerTeam_MlistEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InnerTeam_MlistEntry_DoNotUse, 
    uint64_t, ::inner::InnerTeamMember,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InnerTeam_MlistEntry_DoNotUse, 
    uint64_t, ::inner::InnerTeamMember,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  InnerTeam_MlistEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InnerTeam_MlistEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InnerTeam_MlistEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InnerTeam_MlistEntry_DoNotUse& other);
  static const InnerTeam_MlistEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InnerTeam_MlistEntry_DoNotUse*>(&_InnerTeam_MlistEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_innerteam_2eproto;
};

// -------------------------------------------------------------------

class InnerTeam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inner.InnerTeam) */ {
 public:
  inline InnerTeam() : InnerTeam(nullptr) {}
  ~InnerTeam() override;
  explicit PROTOBUF_CONSTEXPR InnerTeam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerTeam(const InnerTeam& from);
  InnerTeam(InnerTeam&& from) noexcept
    : InnerTeam() {
    *this = ::std::move(from);
  }

  inline InnerTeam& operator=(const InnerTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerTeam& operator=(InnerTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerTeam* internal_default_instance() {
    return reinterpret_cast<const InnerTeam*>(
               &_InnerTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InnerTeam& a, InnerTeam& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerTeam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerTeam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerTeam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerTeam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerTeam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InnerTeam& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerTeam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inner.InnerTeam";
  }
  protected:
  explicit InnerTeam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMlistFieldNumber = 4,
    kBaseFieldNumber = 3,
    kTeamIdFieldNumber = 1,
    kLeadIdFieldNumber = 2,
  };
  // map<uint64, .inner.InnerTeamMember> mlist = 4;
  int mlist_size() const;
  private:
  int _internal_mlist_size() const;
  public:
  void clear_mlist();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >&
      _internal_mlist() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >*
      _internal_mutable_mlist();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >&
      mlist() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >*
      mutable_mlist();

  // .inner.InnerTeamBase base = 3;
  bool has_base() const;
  private:
  bool _internal_has_base() const;
  public:
  void clear_base();
  const ::inner::InnerTeamBase& base() const;
  PROTOBUF_NODISCARD ::inner::InnerTeamBase* release_base();
  ::inner::InnerTeamBase* mutable_base();
  void set_allocated_base(::inner::InnerTeamBase* base);
  private:
  const ::inner::InnerTeamBase& _internal_base() const;
  ::inner::InnerTeamBase* _internal_mutable_base();
  public:
  void unsafe_arena_set_allocated_base(
      ::inner::InnerTeamBase* base);
  ::inner::InnerTeamBase* unsafe_arena_release_base();

  // uint64 teamId = 1;
  void clear_teamid();
  uint64_t teamid() const;
  void set_teamid(uint64_t value);
  private:
  uint64_t _internal_teamid() const;
  void _internal_set_teamid(uint64_t value);
  public:

  // uint64 leadId = 2;
  void clear_leadid();
  uint64_t leadid() const;
  void set_leadid(uint64_t value);
  private:
  uint64_t _internal_leadid() const;
  void _internal_set_leadid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inner.InnerTeam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InnerTeam_MlistEntry_DoNotUse,
      uint64_t, ::inner::InnerTeamMember,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mlist_;
  ::inner::InnerTeamBase* base_;
  uint64_t teamid_;
  uint64_t leadid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_innerteam_2eproto;
};
// -------------------------------------------------------------------

class InnerTeamBase final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inner.InnerTeamBase) */ {
 public:
  inline InnerTeamBase() : InnerTeamBase(nullptr) {}
  ~InnerTeamBase() override;
  explicit PROTOBUF_CONSTEXPR InnerTeamBase(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerTeamBase(const InnerTeamBase& from);
  InnerTeamBase(InnerTeamBase&& from) noexcept
    : InnerTeamBase() {
    *this = ::std::move(from);
  }

  inline InnerTeamBase& operator=(const InnerTeamBase& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerTeamBase& operator=(InnerTeamBase&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerTeamBase& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerTeamBase* internal_default_instance() {
    return reinterpret_cast<const InnerTeamBase*>(
               &_InnerTeamBase_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InnerTeamBase& a, InnerTeamBase& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerTeamBase* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerTeamBase* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerTeamBase* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerTeamBase>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerTeamBase& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InnerTeamBase& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerTeamBase* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inner.InnerTeamBase";
  }
  protected:
  explicit InnerTeamBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdFieldNumber = 1,
    kMinLevelFieldNumber = 2,
    kMaxLevelFieldNumber = 3,
    kMatchTimeFieldNumber = 4,
    kMidwayJoinFieldNumber = 5,
  };
  // uint32 targetId = 1;
  void clear_targetid();
  uint32_t targetid() const;
  void set_targetid(uint32_t value);
  private:
  uint32_t _internal_targetid() const;
  void _internal_set_targetid(uint32_t value);
  public:

  // uint32 minLevel = 2;
  void clear_minlevel();
  uint32_t minlevel() const;
  void set_minlevel(uint32_t value);
  private:
  uint32_t _internal_minlevel() const;
  void _internal_set_minlevel(uint32_t value);
  public:

  // uint32 maxLevel = 3;
  void clear_maxlevel();
  uint32_t maxlevel() const;
  void set_maxlevel(uint32_t value);
  private:
  uint32_t _internal_maxlevel() const;
  void _internal_set_maxlevel(uint32_t value);
  public:

  // uint32 matchTime = 4;
  void clear_matchtime();
  uint32_t matchtime() const;
  void set_matchtime(uint32_t value);
  private:
  uint32_t _internal_matchtime() const;
  void _internal_set_matchtime(uint32_t value);
  public:

  // bool midwayJoin = 5;
  void clear_midwayjoin();
  bool midwayjoin() const;
  void set_midwayjoin(bool value);
  private:
  bool _internal_midwayjoin() const;
  void _internal_set_midwayjoin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:inner.InnerTeamBase)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t targetid_;
  uint32_t minlevel_;
  uint32_t maxlevel_;
  uint32_t matchtime_;
  bool midwayjoin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_innerteam_2eproto;
};
// -------------------------------------------------------------------

class InnerTeamMember final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inner.InnerTeamMember) */ {
 public:
  inline InnerTeamMember() : InnerTeamMember(nullptr) {}
  ~InnerTeamMember() override;
  explicit PROTOBUF_CONSTEXPR InnerTeamMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerTeamMember(const InnerTeamMember& from);
  InnerTeamMember(InnerTeamMember&& from) noexcept
    : InnerTeamMember() {
    *this = ::std::move(from);
  }

  inline InnerTeamMember& operator=(const InnerTeamMember& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerTeamMember& operator=(InnerTeamMember&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerTeamMember& default_instance() {
    return *internal_default_instance();
  }
  static inline const InnerTeamMember* internal_default_instance() {
    return reinterpret_cast<const InnerTeamMember*>(
               &_InnerTeamMember_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InnerTeamMember& a, InnerTeamMember& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerTeamMember* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerTeamMember* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerTeamMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerTeamMember>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerTeamMember& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InnerTeamMember& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerTeamMember* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inner.InnerTeamMember";
  }
  protected:
  explicit InnerTeamMember(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kStateFieldNumber = 2,
    kFollowFieldNumber = 3,
    kSceneIdFieldNumber = 4,
  };
  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // bool state = 2;
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // bool follow = 3;
  void clear_follow();
  bool follow() const;
  void set_follow(bool value);
  private:
  bool _internal_follow() const;
  void _internal_set_follow(bool value);
  public:

  // uint64 sceneId = 4;
  void clear_sceneid();
  uint64_t sceneid() const;
  void set_sceneid(uint64_t value);
  private:
  uint64_t _internal_sceneid() const;
  void _internal_set_sceneid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:inner.InnerTeamMember)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t index_;
  bool state_;
  bool follow_;
  uint64_t sceneid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_innerteam_2eproto;
};
// -------------------------------------------------------------------

class InnerTeamField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inner.InnerTeamField) */ {
 public:
  inline InnerTeamField() : InnerTeamField(nullptr) {}
  ~InnerTeamField() override;
  explicit PROTOBUF_CONSTEXPR InnerTeamField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerTeamField(const InnerTeamField& from);
  InnerTeamField(InnerTeamField&& from) noexcept
    : InnerTeamField() {
    *this = ::std::move(from);
  }

  inline InnerTeamField& operator=(const InnerTeamField& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerTeamField& operator=(InnerTeamField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerTeamField& default_instance() {
    return *internal_default_instance();
  }
  enum FieldCase {
    kLeaderId = 1,
    kTargetId = 2,
    kMinLevel = 3,
    kMaxLevel = 4,
    kMatchTime = 5,
    kText = 6,
    kMidwayJoin = 7,
    FIELD_NOT_SET = 0,
  };

  static inline const InnerTeamField* internal_default_instance() {
    return reinterpret_cast<const InnerTeamField*>(
               &_InnerTeamField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(InnerTeamField& a, InnerTeamField& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerTeamField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerTeamField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerTeamField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerTeamField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerTeamField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InnerTeamField& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerTeamField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inner.InnerTeamField";
  }
  protected:
  explicit InnerTeamField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaderIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kMinLevelFieldNumber = 3,
    kMaxLevelFieldNumber = 4,
    kMatchTimeFieldNumber = 5,
    kTextFieldNumber = 6,
    kMidwayJoinFieldNumber = 7,
  };
  // uint64 leaderId = 1;
  bool has_leaderid() const;
  private:
  bool _internal_has_leaderid() const;
  public:
  void clear_leaderid();
  uint64_t leaderid() const;
  void set_leaderid(uint64_t value);
  private:
  uint64_t _internal_leaderid() const;
  void _internal_set_leaderid(uint64_t value);
  public:

  // uint32 targetId = 2;
  bool has_targetid() const;
  private:
  bool _internal_has_targetid() const;
  public:
  void clear_targetid();
  uint32_t targetid() const;
  void set_targetid(uint32_t value);
  private:
  uint32_t _internal_targetid() const;
  void _internal_set_targetid(uint32_t value);
  public:

  // uint32 minLevel = 3;
  bool has_minlevel() const;
  private:
  bool _internal_has_minlevel() const;
  public:
  void clear_minlevel();
  uint32_t minlevel() const;
  void set_minlevel(uint32_t value);
  private:
  uint32_t _internal_minlevel() const;
  void _internal_set_minlevel(uint32_t value);
  public:

  // uint32 maxLevel = 4;
  bool has_maxlevel() const;
  private:
  bool _internal_has_maxlevel() const;
  public:
  void clear_maxlevel();
  uint32_t maxlevel() const;
  void set_maxlevel(uint32_t value);
  private:
  uint32_t _internal_maxlevel() const;
  void _internal_set_maxlevel(uint32_t value);
  public:

  // uint32 matchTime = 5;
  bool has_matchtime() const;
  private:
  bool _internal_has_matchtime() const;
  public:
  void clear_matchtime();
  uint32_t matchtime() const;
  void set_matchtime(uint32_t value);
  private:
  uint32_t _internal_matchtime() const;
  void _internal_set_matchtime(uint32_t value);
  public:

  // string text = 6;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // bool midwayJoin = 7;
  bool has_midwayjoin() const;
  private:
  bool _internal_has_midwayjoin() const;
  public:
  void clear_midwayjoin();
  bool midwayjoin() const;
  void set_midwayjoin(bool value);
  private:
  bool _internal_midwayjoin() const;
  void _internal_set_midwayjoin(bool value);
  public:

  void clear_field();
  FieldCase field_case() const;
  // @@protoc_insertion_point(class_scope:inner.InnerTeamField)
 private:
  class _Internal;
  void set_has_leaderid();
  void set_has_targetid();
  void set_has_minlevel();
  void set_has_maxlevel();
  void set_has_matchtime();
  void set_has_text();
  void set_has_midwayjoin();

  inline bool has_field() const;
  inline void clear_has_field();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FieldUnion {
    constexpr FieldUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint64_t leaderid_;
    uint32_t targetid_;
    uint32_t minlevel_;
    uint32_t maxlevel_;
    uint32_t matchtime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    bool midwayjoin_;
  } field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_innerteam_2eproto;
};
// -------------------------------------------------------------------

class InnerTeamMemberField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:inner.InnerTeamMemberField) */ {
 public:
  inline InnerTeamMemberField() : InnerTeamMemberField(nullptr) {}
  ~InnerTeamMemberField() override;
  explicit PROTOBUF_CONSTEXPR InnerTeamMemberField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InnerTeamMemberField(const InnerTeamMemberField& from);
  InnerTeamMemberField(InnerTeamMemberField&& from) noexcept
    : InnerTeamMemberField() {
    *this = ::std::move(from);
  }

  inline InnerTeamMemberField& operator=(const InnerTeamMemberField& from) {
    CopyFrom(from);
    return *this;
  }
  inline InnerTeamMemberField& operator=(InnerTeamMemberField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InnerTeamMemberField& default_instance() {
    return *internal_default_instance();
  }
  enum FieldCase {
    kIndex = 1,
    kState = 2,
    kFollow = 3,
    kSceneId = 4,
    FIELD_NOT_SET = 0,
  };

  static inline const InnerTeamMemberField* internal_default_instance() {
    return reinterpret_cast<const InnerTeamMemberField*>(
               &_InnerTeamMemberField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InnerTeamMemberField& a, InnerTeamMemberField& b) {
    a.Swap(&b);
  }
  inline void Swap(InnerTeamMemberField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InnerTeamMemberField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InnerTeamMemberField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InnerTeamMemberField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InnerTeamMemberField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InnerTeamMemberField& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InnerTeamMemberField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "inner.InnerTeamMemberField";
  }
  protected:
  explicit InnerTeamMemberField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kStateFieldNumber = 2,
    kFollowFieldNumber = 3,
    kSceneIdFieldNumber = 4,
  };
  // uint32 index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // bool state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  bool state() const;
  void set_state(bool value);
  private:
  bool _internal_state() const;
  void _internal_set_state(bool value);
  public:

  // bool follow = 3;
  bool has_follow() const;
  private:
  bool _internal_has_follow() const;
  public:
  void clear_follow();
  bool follow() const;
  void set_follow(bool value);
  private:
  bool _internal_follow() const;
  void _internal_set_follow(bool value);
  public:

  // uint64 sceneId = 4;
  bool has_sceneid() const;
  private:
  bool _internal_has_sceneid() const;
  public:
  void clear_sceneid();
  uint64_t sceneid() const;
  void set_sceneid(uint64_t value);
  private:
  uint64_t _internal_sceneid() const;
  void _internal_set_sceneid(uint64_t value);
  public:

  void clear_field();
  FieldCase field_case() const;
  // @@protoc_insertion_point(class_scope:inner.InnerTeamMemberField)
 private:
  class _Internal;
  void set_has_index();
  void set_has_state();
  void set_has_follow();
  void set_has_sceneid();

  inline bool has_field() const;
  inline void clear_has_field();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FieldUnion {
    constexpr FieldUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    uint32_t index_;
    bool state_;
    bool follow_;
    uint64_t sceneid_;
  } field_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_innerteam_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InnerTeamList

// repeated .inner.InnerTeam teams = 1;
inline int InnerTeamList::_internal_teams_size() const {
  return teams_.size();
}
inline int InnerTeamList::teams_size() const {
  return _internal_teams_size();
}
inline void InnerTeamList::clear_teams() {
  teams_.Clear();
}
inline ::inner::InnerTeam* InnerTeamList::mutable_teams(int index) {
  // @@protoc_insertion_point(field_mutable:inner.InnerTeamList.teams)
  return teams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inner::InnerTeam >*
InnerTeamList::mutable_teams() {
  // @@protoc_insertion_point(field_mutable_list:inner.InnerTeamList.teams)
  return &teams_;
}
inline const ::inner::InnerTeam& InnerTeamList::_internal_teams(int index) const {
  return teams_.Get(index);
}
inline const ::inner::InnerTeam& InnerTeamList::teams(int index) const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamList.teams)
  return _internal_teams(index);
}
inline ::inner::InnerTeam* InnerTeamList::_internal_add_teams() {
  return teams_.Add();
}
inline ::inner::InnerTeam* InnerTeamList::add_teams() {
  ::inner::InnerTeam* _add = _internal_add_teams();
  // @@protoc_insertion_point(field_add:inner.InnerTeamList.teams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::inner::InnerTeam >&
InnerTeamList::teams() const {
  // @@protoc_insertion_point(field_list:inner.InnerTeamList.teams)
  return teams_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InnerTeam

// uint64 teamId = 1;
inline void InnerTeam::clear_teamid() {
  teamid_ = uint64_t{0u};
}
inline uint64_t InnerTeam::_internal_teamid() const {
  return teamid_;
}
inline uint64_t InnerTeam::teamid() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeam.teamId)
  return _internal_teamid();
}
inline void InnerTeam::_internal_set_teamid(uint64_t value) {
  
  teamid_ = value;
}
inline void InnerTeam::set_teamid(uint64_t value) {
  _internal_set_teamid(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeam.teamId)
}

// uint64 leadId = 2;
inline void InnerTeam::clear_leadid() {
  leadid_ = uint64_t{0u};
}
inline uint64_t InnerTeam::_internal_leadid() const {
  return leadid_;
}
inline uint64_t InnerTeam::leadid() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeam.leadId)
  return _internal_leadid();
}
inline void InnerTeam::_internal_set_leadid(uint64_t value) {
  
  leadid_ = value;
}
inline void InnerTeam::set_leadid(uint64_t value) {
  _internal_set_leadid(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeam.leadId)
}

// .inner.InnerTeamBase base = 3;
inline bool InnerTeam::_internal_has_base() const {
  return this != internal_default_instance() && base_ != nullptr;
}
inline bool InnerTeam::has_base() const {
  return _internal_has_base();
}
inline void InnerTeam::clear_base() {
  if (GetArenaForAllocation() == nullptr && base_ != nullptr) {
    delete base_;
  }
  base_ = nullptr;
}
inline const ::inner::InnerTeamBase& InnerTeam::_internal_base() const {
  const ::inner::InnerTeamBase* p = base_;
  return p != nullptr ? *p : reinterpret_cast<const ::inner::InnerTeamBase&>(
      ::inner::_InnerTeamBase_default_instance_);
}
inline const ::inner::InnerTeamBase& InnerTeam::base() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeam.base)
  return _internal_base();
}
inline void InnerTeam::unsafe_arena_set_allocated_base(
    ::inner::InnerTeamBase* base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:inner.InnerTeam.base)
}
inline ::inner::InnerTeamBase* InnerTeam::release_base() {
  
  ::inner::InnerTeamBase* temp = base_;
  base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::inner::InnerTeamBase* InnerTeam::unsafe_arena_release_base() {
  // @@protoc_insertion_point(field_release:inner.InnerTeam.base)
  
  ::inner::InnerTeamBase* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::inner::InnerTeamBase* InnerTeam::_internal_mutable_base() {
  
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::inner::InnerTeamBase>(GetArenaForAllocation());
    base_ = p;
  }
  return base_;
}
inline ::inner::InnerTeamBase* InnerTeam::mutable_base() {
  ::inner::InnerTeamBase* _msg = _internal_mutable_base();
  // @@protoc_insertion_point(field_mutable:inner.InnerTeam.base)
  return _msg;
}
inline void InnerTeam::set_allocated_base(::inner::InnerTeamBase* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete base_;
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base);
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:inner.InnerTeam.base)
}

// map<uint64, .inner.InnerTeamMember> mlist = 4;
inline int InnerTeam::_internal_mlist_size() const {
  return mlist_.size();
}
inline int InnerTeam::mlist_size() const {
  return _internal_mlist_size();
}
inline void InnerTeam::clear_mlist() {
  mlist_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >&
InnerTeam::_internal_mlist() const {
  return mlist_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >&
InnerTeam::mlist() const {
  // @@protoc_insertion_point(field_map:inner.InnerTeam.mlist)
  return _internal_mlist();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >*
InnerTeam::_internal_mutable_mlist() {
  return mlist_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint64_t, ::inner::InnerTeamMember >*
InnerTeam::mutable_mlist() {
  // @@protoc_insertion_point(field_mutable_map:inner.InnerTeam.mlist)
  return _internal_mutable_mlist();
}

// -------------------------------------------------------------------

// InnerTeamBase

// uint32 targetId = 1;
inline void InnerTeamBase::clear_targetid() {
  targetid_ = 0u;
}
inline uint32_t InnerTeamBase::_internal_targetid() const {
  return targetid_;
}
inline uint32_t InnerTeamBase::targetid() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamBase.targetId)
  return _internal_targetid();
}
inline void InnerTeamBase::_internal_set_targetid(uint32_t value) {
  
  targetid_ = value;
}
inline void InnerTeamBase::set_targetid(uint32_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamBase.targetId)
}

// uint32 minLevel = 2;
inline void InnerTeamBase::clear_minlevel() {
  minlevel_ = 0u;
}
inline uint32_t InnerTeamBase::_internal_minlevel() const {
  return minlevel_;
}
inline uint32_t InnerTeamBase::minlevel() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamBase.minLevel)
  return _internal_minlevel();
}
inline void InnerTeamBase::_internal_set_minlevel(uint32_t value) {
  
  minlevel_ = value;
}
inline void InnerTeamBase::set_minlevel(uint32_t value) {
  _internal_set_minlevel(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamBase.minLevel)
}

// uint32 maxLevel = 3;
inline void InnerTeamBase::clear_maxlevel() {
  maxlevel_ = 0u;
}
inline uint32_t InnerTeamBase::_internal_maxlevel() const {
  return maxlevel_;
}
inline uint32_t InnerTeamBase::maxlevel() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamBase.maxLevel)
  return _internal_maxlevel();
}
inline void InnerTeamBase::_internal_set_maxlevel(uint32_t value) {
  
  maxlevel_ = value;
}
inline void InnerTeamBase::set_maxlevel(uint32_t value) {
  _internal_set_maxlevel(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamBase.maxLevel)
}

// uint32 matchTime = 4;
inline void InnerTeamBase::clear_matchtime() {
  matchtime_ = 0u;
}
inline uint32_t InnerTeamBase::_internal_matchtime() const {
  return matchtime_;
}
inline uint32_t InnerTeamBase::matchtime() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamBase.matchTime)
  return _internal_matchtime();
}
inline void InnerTeamBase::_internal_set_matchtime(uint32_t value) {
  
  matchtime_ = value;
}
inline void InnerTeamBase::set_matchtime(uint32_t value) {
  _internal_set_matchtime(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamBase.matchTime)
}

// bool midwayJoin = 5;
inline void InnerTeamBase::clear_midwayjoin() {
  midwayjoin_ = false;
}
inline bool InnerTeamBase::_internal_midwayjoin() const {
  return midwayjoin_;
}
inline bool InnerTeamBase::midwayjoin() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamBase.midwayJoin)
  return _internal_midwayjoin();
}
inline void InnerTeamBase::_internal_set_midwayjoin(bool value) {
  
  midwayjoin_ = value;
}
inline void InnerTeamBase::set_midwayjoin(bool value) {
  _internal_set_midwayjoin(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamBase.midwayJoin)
}

// -------------------------------------------------------------------

// InnerTeamMember

// uint32 index = 1;
inline void InnerTeamMember::clear_index() {
  index_ = 0u;
}
inline uint32_t InnerTeamMember::_internal_index() const {
  return index_;
}
inline uint32_t InnerTeamMember::index() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMember.index)
  return _internal_index();
}
inline void InnerTeamMember::_internal_set_index(uint32_t value) {
  
  index_ = value;
}
inline void InnerTeamMember::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMember.index)
}

// bool state = 2;
inline void InnerTeamMember::clear_state() {
  state_ = false;
}
inline bool InnerTeamMember::_internal_state() const {
  return state_;
}
inline bool InnerTeamMember::state() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMember.state)
  return _internal_state();
}
inline void InnerTeamMember::_internal_set_state(bool value) {
  
  state_ = value;
}
inline void InnerTeamMember::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMember.state)
}

// bool follow = 3;
inline void InnerTeamMember::clear_follow() {
  follow_ = false;
}
inline bool InnerTeamMember::_internal_follow() const {
  return follow_;
}
inline bool InnerTeamMember::follow() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMember.follow)
  return _internal_follow();
}
inline void InnerTeamMember::_internal_set_follow(bool value) {
  
  follow_ = value;
}
inline void InnerTeamMember::set_follow(bool value) {
  _internal_set_follow(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMember.follow)
}

// uint64 sceneId = 4;
inline void InnerTeamMember::clear_sceneid() {
  sceneid_ = uint64_t{0u};
}
inline uint64_t InnerTeamMember::_internal_sceneid() const {
  return sceneid_;
}
inline uint64_t InnerTeamMember::sceneid() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMember.sceneId)
  return _internal_sceneid();
}
inline void InnerTeamMember::_internal_set_sceneid(uint64_t value) {
  
  sceneid_ = value;
}
inline void InnerTeamMember::set_sceneid(uint64_t value) {
  _internal_set_sceneid(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMember.sceneId)
}

// -------------------------------------------------------------------

// InnerTeamField

// uint64 leaderId = 1;
inline bool InnerTeamField::_internal_has_leaderid() const {
  return field_case() == kLeaderId;
}
inline bool InnerTeamField::has_leaderid() const {
  return _internal_has_leaderid();
}
inline void InnerTeamField::set_has_leaderid() {
  _oneof_case_[0] = kLeaderId;
}
inline void InnerTeamField::clear_leaderid() {
  if (_internal_has_leaderid()) {
    field_.leaderid_ = uint64_t{0u};
    clear_has_field();
  }
}
inline uint64_t InnerTeamField::_internal_leaderid() const {
  if (_internal_has_leaderid()) {
    return field_.leaderid_;
  }
  return uint64_t{0u};
}
inline void InnerTeamField::_internal_set_leaderid(uint64_t value) {
  if (!_internal_has_leaderid()) {
    clear_field();
    set_has_leaderid();
  }
  field_.leaderid_ = value;
}
inline uint64_t InnerTeamField::leaderid() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamField.leaderId)
  return _internal_leaderid();
}
inline void InnerTeamField::set_leaderid(uint64_t value) {
  _internal_set_leaderid(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamField.leaderId)
}

// uint32 targetId = 2;
inline bool InnerTeamField::_internal_has_targetid() const {
  return field_case() == kTargetId;
}
inline bool InnerTeamField::has_targetid() const {
  return _internal_has_targetid();
}
inline void InnerTeamField::set_has_targetid() {
  _oneof_case_[0] = kTargetId;
}
inline void InnerTeamField::clear_targetid() {
  if (_internal_has_targetid()) {
    field_.targetid_ = 0u;
    clear_has_field();
  }
}
inline uint32_t InnerTeamField::_internal_targetid() const {
  if (_internal_has_targetid()) {
    return field_.targetid_;
  }
  return 0u;
}
inline void InnerTeamField::_internal_set_targetid(uint32_t value) {
  if (!_internal_has_targetid()) {
    clear_field();
    set_has_targetid();
  }
  field_.targetid_ = value;
}
inline uint32_t InnerTeamField::targetid() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamField.targetId)
  return _internal_targetid();
}
inline void InnerTeamField::set_targetid(uint32_t value) {
  _internal_set_targetid(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamField.targetId)
}

// uint32 minLevel = 3;
inline bool InnerTeamField::_internal_has_minlevel() const {
  return field_case() == kMinLevel;
}
inline bool InnerTeamField::has_minlevel() const {
  return _internal_has_minlevel();
}
inline void InnerTeamField::set_has_minlevel() {
  _oneof_case_[0] = kMinLevel;
}
inline void InnerTeamField::clear_minlevel() {
  if (_internal_has_minlevel()) {
    field_.minlevel_ = 0u;
    clear_has_field();
  }
}
inline uint32_t InnerTeamField::_internal_minlevel() const {
  if (_internal_has_minlevel()) {
    return field_.minlevel_;
  }
  return 0u;
}
inline void InnerTeamField::_internal_set_minlevel(uint32_t value) {
  if (!_internal_has_minlevel()) {
    clear_field();
    set_has_minlevel();
  }
  field_.minlevel_ = value;
}
inline uint32_t InnerTeamField::minlevel() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamField.minLevel)
  return _internal_minlevel();
}
inline void InnerTeamField::set_minlevel(uint32_t value) {
  _internal_set_minlevel(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamField.minLevel)
}

// uint32 maxLevel = 4;
inline bool InnerTeamField::_internal_has_maxlevel() const {
  return field_case() == kMaxLevel;
}
inline bool InnerTeamField::has_maxlevel() const {
  return _internal_has_maxlevel();
}
inline void InnerTeamField::set_has_maxlevel() {
  _oneof_case_[0] = kMaxLevel;
}
inline void InnerTeamField::clear_maxlevel() {
  if (_internal_has_maxlevel()) {
    field_.maxlevel_ = 0u;
    clear_has_field();
  }
}
inline uint32_t InnerTeamField::_internal_maxlevel() const {
  if (_internal_has_maxlevel()) {
    return field_.maxlevel_;
  }
  return 0u;
}
inline void InnerTeamField::_internal_set_maxlevel(uint32_t value) {
  if (!_internal_has_maxlevel()) {
    clear_field();
    set_has_maxlevel();
  }
  field_.maxlevel_ = value;
}
inline uint32_t InnerTeamField::maxlevel() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamField.maxLevel)
  return _internal_maxlevel();
}
inline void InnerTeamField::set_maxlevel(uint32_t value) {
  _internal_set_maxlevel(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamField.maxLevel)
}

// uint32 matchTime = 5;
inline bool InnerTeamField::_internal_has_matchtime() const {
  return field_case() == kMatchTime;
}
inline bool InnerTeamField::has_matchtime() const {
  return _internal_has_matchtime();
}
inline void InnerTeamField::set_has_matchtime() {
  _oneof_case_[0] = kMatchTime;
}
inline void InnerTeamField::clear_matchtime() {
  if (_internal_has_matchtime()) {
    field_.matchtime_ = 0u;
    clear_has_field();
  }
}
inline uint32_t InnerTeamField::_internal_matchtime() const {
  if (_internal_has_matchtime()) {
    return field_.matchtime_;
  }
  return 0u;
}
inline void InnerTeamField::_internal_set_matchtime(uint32_t value) {
  if (!_internal_has_matchtime()) {
    clear_field();
    set_has_matchtime();
  }
  field_.matchtime_ = value;
}
inline uint32_t InnerTeamField::matchtime() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamField.matchTime)
  return _internal_matchtime();
}
inline void InnerTeamField::set_matchtime(uint32_t value) {
  _internal_set_matchtime(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamField.matchTime)
}

// string text = 6;
inline bool InnerTeamField::_internal_has_text() const {
  return field_case() == kText;
}
inline bool InnerTeamField::has_text() const {
  return _internal_has_text();
}
inline void InnerTeamField::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void InnerTeamField::clear_text() {
  if (_internal_has_text()) {
    field_.text_.Destroy();
    clear_has_field();
  }
}
inline const std::string& InnerTeamField::text() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamField.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void InnerTeamField::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_field();
    set_has_text();
    field_.text_.InitDefault();
  }
  field_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:inner.InnerTeamField.text)
}
inline std::string* InnerTeamField::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:inner.InnerTeamField.text)
  return _s;
}
inline const std::string& InnerTeamField::_internal_text() const {
  if (_internal_has_text()) {
    return field_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InnerTeamField::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_field();
    set_has_text();
    field_.text_.InitDefault();
  }
  field_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* InnerTeamField::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_field();
    set_has_text();
    field_.text_.InitDefault();
  }
  return field_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* InnerTeamField::release_text() {
  // @@protoc_insertion_point(field_release:inner.InnerTeamField.text)
  if (_internal_has_text()) {
    clear_has_field();
    return field_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void InnerTeamField::set_allocated_text(std::string* text) {
  if (has_field()) {
    clear_field();
  }
  if (text != nullptr) {
    set_has_text();
    field_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:inner.InnerTeamField.text)
}

// bool midwayJoin = 7;
inline bool InnerTeamField::_internal_has_midwayjoin() const {
  return field_case() == kMidwayJoin;
}
inline bool InnerTeamField::has_midwayjoin() const {
  return _internal_has_midwayjoin();
}
inline void InnerTeamField::set_has_midwayjoin() {
  _oneof_case_[0] = kMidwayJoin;
}
inline void InnerTeamField::clear_midwayjoin() {
  if (_internal_has_midwayjoin()) {
    field_.midwayjoin_ = false;
    clear_has_field();
  }
}
inline bool InnerTeamField::_internal_midwayjoin() const {
  if (_internal_has_midwayjoin()) {
    return field_.midwayjoin_;
  }
  return false;
}
inline void InnerTeamField::_internal_set_midwayjoin(bool value) {
  if (!_internal_has_midwayjoin()) {
    clear_field();
    set_has_midwayjoin();
  }
  field_.midwayjoin_ = value;
}
inline bool InnerTeamField::midwayjoin() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamField.midwayJoin)
  return _internal_midwayjoin();
}
inline void InnerTeamField::set_midwayjoin(bool value) {
  _internal_set_midwayjoin(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamField.midwayJoin)
}

inline bool InnerTeamField::has_field() const {
  return field_case() != FIELD_NOT_SET;
}
inline void InnerTeamField::clear_has_field() {
  _oneof_case_[0] = FIELD_NOT_SET;
}
inline InnerTeamField::FieldCase InnerTeamField::field_case() const {
  return InnerTeamField::FieldCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InnerTeamMemberField

// uint32 index = 1;
inline bool InnerTeamMemberField::_internal_has_index() const {
  return field_case() == kIndex;
}
inline bool InnerTeamMemberField::has_index() const {
  return _internal_has_index();
}
inline void InnerTeamMemberField::set_has_index() {
  _oneof_case_[0] = kIndex;
}
inline void InnerTeamMemberField::clear_index() {
  if (_internal_has_index()) {
    field_.index_ = 0u;
    clear_has_field();
  }
}
inline uint32_t InnerTeamMemberField::_internal_index() const {
  if (_internal_has_index()) {
    return field_.index_;
  }
  return 0u;
}
inline void InnerTeamMemberField::_internal_set_index(uint32_t value) {
  if (!_internal_has_index()) {
    clear_field();
    set_has_index();
  }
  field_.index_ = value;
}
inline uint32_t InnerTeamMemberField::index() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMemberField.index)
  return _internal_index();
}
inline void InnerTeamMemberField::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMemberField.index)
}

// bool state = 2;
inline bool InnerTeamMemberField::_internal_has_state() const {
  return field_case() == kState;
}
inline bool InnerTeamMemberField::has_state() const {
  return _internal_has_state();
}
inline void InnerTeamMemberField::set_has_state() {
  _oneof_case_[0] = kState;
}
inline void InnerTeamMemberField::clear_state() {
  if (_internal_has_state()) {
    field_.state_ = false;
    clear_has_field();
  }
}
inline bool InnerTeamMemberField::_internal_state() const {
  if (_internal_has_state()) {
    return field_.state_;
  }
  return false;
}
inline void InnerTeamMemberField::_internal_set_state(bool value) {
  if (!_internal_has_state()) {
    clear_field();
    set_has_state();
  }
  field_.state_ = value;
}
inline bool InnerTeamMemberField::state() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMemberField.state)
  return _internal_state();
}
inline void InnerTeamMemberField::set_state(bool value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMemberField.state)
}

// bool follow = 3;
inline bool InnerTeamMemberField::_internal_has_follow() const {
  return field_case() == kFollow;
}
inline bool InnerTeamMemberField::has_follow() const {
  return _internal_has_follow();
}
inline void InnerTeamMemberField::set_has_follow() {
  _oneof_case_[0] = kFollow;
}
inline void InnerTeamMemberField::clear_follow() {
  if (_internal_has_follow()) {
    field_.follow_ = false;
    clear_has_field();
  }
}
inline bool InnerTeamMemberField::_internal_follow() const {
  if (_internal_has_follow()) {
    return field_.follow_;
  }
  return false;
}
inline void InnerTeamMemberField::_internal_set_follow(bool value) {
  if (!_internal_has_follow()) {
    clear_field();
    set_has_follow();
  }
  field_.follow_ = value;
}
inline bool InnerTeamMemberField::follow() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMemberField.follow)
  return _internal_follow();
}
inline void InnerTeamMemberField::set_follow(bool value) {
  _internal_set_follow(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMemberField.follow)
}

// uint64 sceneId = 4;
inline bool InnerTeamMemberField::_internal_has_sceneid() const {
  return field_case() == kSceneId;
}
inline bool InnerTeamMemberField::has_sceneid() const {
  return _internal_has_sceneid();
}
inline void InnerTeamMemberField::set_has_sceneid() {
  _oneof_case_[0] = kSceneId;
}
inline void InnerTeamMemberField::clear_sceneid() {
  if (_internal_has_sceneid()) {
    field_.sceneid_ = uint64_t{0u};
    clear_has_field();
  }
}
inline uint64_t InnerTeamMemberField::_internal_sceneid() const {
  if (_internal_has_sceneid()) {
    return field_.sceneid_;
  }
  return uint64_t{0u};
}
inline void InnerTeamMemberField::_internal_set_sceneid(uint64_t value) {
  if (!_internal_has_sceneid()) {
    clear_field();
    set_has_sceneid();
  }
  field_.sceneid_ = value;
}
inline uint64_t InnerTeamMemberField::sceneid() const {
  // @@protoc_insertion_point(field_get:inner.InnerTeamMemberField.sceneId)
  return _internal_sceneid();
}
inline void InnerTeamMemberField::set_sceneid(uint64_t value) {
  _internal_set_sceneid(value);
  // @@protoc_insertion_point(field_set:inner.InnerTeamMemberField.sceneId)
}

inline bool InnerTeamMemberField::has_field() const {
  return field_case() != FIELD_NOT_SET;
}
inline void InnerTeamMemberField::clear_has_field() {
  _oneof_case_[0] = FIELD_NOT_SET;
}
inline InnerTeamMemberField::FieldCase InnerTeamMemberField::field_case() const {
  return InnerTeamMemberField::FieldCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace inner

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::inner::InnerTeamFieldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inner::InnerTeamFieldType>() {
  return ::inner::InnerTeamFieldType_descriptor();
}
template <> struct is_proto_enum< ::inner::InnerTeamMemberFieldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inner::InnerTeamMemberFieldType>() {
  return ::inner::InnerTeamMemberFieldType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_innerteam_2eproto
