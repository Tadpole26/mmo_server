// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: map_cfg.proto

#include "map_cfg.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace packet {
PROTOBUF_CONSTEXPR BrushInfo_RigIdNpc_NpcUnit::BrushInfo_RigIdNpc_NpcUnit(
    ::_pbi::ConstantInitialized)
  : npcid_(0u)
  , locationoffsetx_(0)
  , locationoffsety_(0)
  , rotationoffsetx_(0)
  , rotationoffsety_(0)
  , rotationoffsetz_(0)
  , triggerareax_(0)
  , triggerareay_(0)
  , triggerareaz_(0)
  , triggerareaoffsetx_(0)
  , triggerareaoffsety_(0){}
struct BrushInfo_RigIdNpc_NpcUnitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInfo_RigIdNpc_NpcUnitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInfo_RigIdNpc_NpcUnitDefaultTypeInternal() {}
  union {
    BrushInfo_RigIdNpc_NpcUnit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInfo_RigIdNpc_NpcUnitDefaultTypeInternal _BrushInfo_RigIdNpc_NpcUnit_default_instance_;
PROTOBUF_CONSTEXPR BrushInfo_RigIdNpc::BrushInfo_RigIdNpc(
    ::_pbi::ConstantInitialized)
  : vecnpcs_(){}
struct BrushInfo_RigIdNpcDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInfo_RigIdNpcDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInfo_RigIdNpcDefaultTypeInternal() {}
  union {
    BrushInfo_RigIdNpc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInfo_RigIdNpcDefaultTypeInternal _BrushInfo_RigIdNpc_default_instance_;
PROTOBUF_CONSTEXPR BrushInfo_Teleporter::BrushInfo_Teleporter(
    ::_pbi::ConstantInitialized)
  : teleporttype_(0u)
  , targetmap_(0u)
  , locationx_(0)
  , locationy_(0)
  , rotationx_(0)
  , rotationy_(0)
  , rotationz_(0)
  , triggerareax_(0)
  , triggerareay_(0)
  , triggerareaz_(0)
  , triggerareaoffsetx_(0)
  , triggerareaoffsety_(0)
  , teleportanim_(0u){}
struct BrushInfo_TeleporterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInfo_TeleporterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInfo_TeleporterDefaultTypeInternal() {}
  union {
    BrushInfo_Teleporter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInfo_TeleporterDefaultTypeInternal _BrushInfo_Teleporter_default_instance_;
PROTOBUF_CONSTEXPR BrushInfo_BlockArea::BrushInfo_BlockArea(
    ::_pbi::ConstantInitialized)
  : blockareaid_(0u)
  , blockareax_(0)
  , blockareay_(0)
  , blockareaz_(0)
  , blockareaoffsetx_(0)
  , blockareaoffsety_(0){}
struct BrushInfo_BlockAreaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInfo_BlockAreaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInfo_BlockAreaDefaultTypeInternal() {}
  union {
    BrushInfo_BlockArea _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInfo_BlockAreaDefaultTypeInternal _BrushInfo_BlockArea_default_instance_;
PROTOBUF_CONSTEXPR BrushInfo::BrushInfo(
    ::_pbi::ConstantInitialized){}
struct BrushInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInfoDefaultTypeInternal() {}
  union {
    BrushInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInfoDefaultTypeInternal _BrushInfo_default_instance_;
PROTOBUF_CONSTEXPR BrushAll::BrushAll(
    ::_pbi::ConstantInitialized)
  : brushinfos_(){}
struct BrushAllDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushAllDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushAllDefaultTypeInternal() {}
  union {
    BrushAll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushAllDefaultTypeInternal _BrushAll_default_instance_;
PROTOBUF_CONSTEXPR BrushInMapInfo_Range::BrushInMapInfo_Range(
    ::_pbi::ConstantInitialized)
  : maxposx_(0u)
  , maxposy_(0u){}
struct BrushInMapInfo_RangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInMapInfo_RangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInMapInfo_RangeDefaultTypeInternal() {}
  union {
    BrushInMapInfo_Range _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInMapInfo_RangeDefaultTypeInternal _BrushInMapInfo_Range_default_instance_;
PROTOBUF_CONSTEXPR BrushInMapInfo_Point::BrushInMapInfo_Point(
    ::_pbi::ConstantInitialized)
  : posx_(0u)
  , posy_(0u)
  , rotx_(0u)
  , roty_(0u)
  , rotz_(0u){}
struct BrushInMapInfo_PointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInMapInfo_PointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInMapInfo_PointDefaultTypeInternal() {}
  union {
    BrushInMapInfo_Point _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInMapInfo_PointDefaultTypeInternal _BrushInMapInfo_Point_default_instance_;
PROTOBUF_CONSTEXPR BrushInMapInfo_PointGroup::BrushInMapInfo_PointGroup(
    ::_pbi::ConstantInitialized)
  : points_(){}
struct BrushInMapInfo_PointGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInMapInfo_PointGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInMapInfo_PointGroupDefaultTypeInternal() {}
  union {
    BrushInMapInfo_PointGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInMapInfo_PointGroupDefaultTypeInternal _BrushInMapInfo_PointGroup_default_instance_;
PROTOBUF_CONSTEXPR BrushInMapInfo::BrushInMapInfo(
    ::_pbi::ConstantInitialized)
  : point_(nullptr)
  , vecpoint_(nullptr)
  , range_(nullptr)
  , brushid_(uint64_t{0u})
  , type_(0u){}
struct BrushInMapInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BrushInMapInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BrushInMapInfoDefaultTypeInternal() {}
  union {
    BrushInMapInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BrushInMapInfoDefaultTypeInternal _BrushInMapInfo_default_instance_;
}  // namespace packet
static ::_pb::Metadata file_level_metadata_map_5fcfg_2eproto[10];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_map_5fcfg_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_map_5fcfg_2eproto = nullptr;

const uint32_t TableStruct_map_5fcfg_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, npcid_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, locationoffsetx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, locationoffsety_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, rotationoffsetx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, rotationoffsety_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, rotationoffsetz_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, triggerareax_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, triggerareay_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, triggerareaz_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, triggerareaoffsetx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc_NpcUnit, triggerareaoffsety_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_RigIdNpc, vecnpcs_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, teleporttype_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, targetmap_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, locationx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, locationy_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, rotationx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, rotationy_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, rotationz_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, triggerareax_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, triggerareay_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, triggerareaz_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, triggerareaoffsetx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, triggerareaoffsety_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_Teleporter, teleportanim_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_BlockArea, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_BlockArea, blockareaid_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_BlockArea, blockareax_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_BlockArea, blockareay_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_BlockArea, blockareaz_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_BlockArea, blockareaoffsetx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo_BlockArea, blockareaoffsety_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushAll, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushAll, brushinfos_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Range, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Range, maxposx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Range, maxposy_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Point, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Point, posx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Point, posy_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Point, rotx_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Point, roty_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_Point, rotz_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_PointGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo_PointGroup, points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo, type_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo, brushid_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo, point_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo, vecpoint_),
  PROTOBUF_FIELD_OFFSET(::packet::BrushInMapInfo, range_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::packet::BrushInfo_RigIdNpc_NpcUnit)},
  { 17, -1, -1, sizeof(::packet::BrushInfo_RigIdNpc)},
  { 24, -1, -1, sizeof(::packet::BrushInfo_Teleporter)},
  { 43, -1, -1, sizeof(::packet::BrushInfo_BlockArea)},
  { 55, -1, -1, sizeof(::packet::BrushInfo)},
  { 61, -1, -1, sizeof(::packet::BrushAll)},
  { 68, -1, -1, sizeof(::packet::BrushInMapInfo_Range)},
  { 76, -1, -1, sizeof(::packet::BrushInMapInfo_Point)},
  { 87, -1, -1, sizeof(::packet::BrushInMapInfo_PointGroup)},
  { 94, -1, -1, sizeof(::packet::BrushInMapInfo)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::packet::_BrushInfo_RigIdNpc_NpcUnit_default_instance_._instance,
  &::packet::_BrushInfo_RigIdNpc_default_instance_._instance,
  &::packet::_BrushInfo_Teleporter_default_instance_._instance,
  &::packet::_BrushInfo_BlockArea_default_instance_._instance,
  &::packet::_BrushInfo_default_instance_._instance,
  &::packet::_BrushAll_default_instance_._instance,
  &::packet::_BrushInMapInfo_Range_default_instance_._instance,
  &::packet::_BrushInMapInfo_Point_default_instance_._instance,
  &::packet::_BrushInMapInfo_PointGroup_default_instance_._instance,
  &::packet::_BrushInMapInfo_default_instance_._instance,
};

const char descriptor_table_protodef_map_5fcfg_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rmap_cfg.proto\022\006packet\"\231\006\n\tBrushInfo\032\321\002"
  "\n\010RigIdNpc\0223\n\007vecNpcs\030\001 \003(\0132\".packet.Bru"
  "shInfo.RigIdNpc.NpcUnit\032\217\002\n\007NpcUnit\022\r\n\005n"
  "pcId\030\001 \001(\r\022\027\n\017locationOffsetX\030\002 \001(\002\022\027\n\017l"
  "ocationOffsetY\030\003 \001(\002\022\027\n\017rotationOffsetX\030"
  "\004 \001(\002\022\027\n\017rotationOffsetY\030\005 \001(\002\022\027\n\017rotati"
  "onOffsetZ\030\006 \001(\002\022\024\n\014triggerAreaX\030\007 \001(\002\022\024\n"
  "\014triggerAreaY\030\010 \001(\002\022\024\n\014triggerAreaZ\030\t \001("
  "\002\022\032\n\022triggerAreaOffsetX\030\n \001(\002\022\032\n\022trigger"
  "AreaOffsetY\030\013 \001(\002\032\244\002\n\nTeleporter\022\024\n\014tele"
  "portType\030\001 \001(\r\022\021\n\ttargetMap\030\002 \001(\r\022\021\n\tloc"
  "ationX\030\003 \001(\002\022\021\n\tlocationY\030\004 \001(\002\022\021\n\trotat"
  "ionX\030\005 \001(\002\022\021\n\trotationY\030\006 \001(\002\022\021\n\trotatio"
  "nZ\030\007 \001(\002\022\024\n\014triggerAreaX\030\010 \001(\002\022\024\n\014trigge"
  "rAreaY\030\t \001(\002\022\024\n\014triggerAreaZ\030\n \001(\002\022\032\n\022tr"
  "iggerAreaOffsetX\030\013 \001(\002\022\032\n\022triggerAreaOff"
  "setY\030\014 \001(\002\022\024\n\014teleportAnim\030\r \001(\r\032\220\001\n\tBlo"
  "ckArea\022\023\n\013blockAreaId\030\001 \001(\r\022\022\n\nblockArea"
  "X\030\002 \001(\002\022\022\n\nblockAreaY\030\003 \001(\002\022\022\n\nblockArea"
  "Z\030\004 \001(\002\022\030\n\020blockAreaOffsetX\030\005 \001(\002\022\030\n\020blo"
  "ckAreaOffsetY\030\006 \001(\002\"1\n\010BrushAll\022%\n\nbrush"
  "Infos\030\001 \003(\0132\021.packet.BrushInfo\"\364\002\n\016Brush"
  "InMapInfo\022\014\n\004type\030\001 \001(\r\022\017\n\007brushId\030\002 \001(\004"
  "\022+\n\005point\030\003 \001(\0132\034.packet.BrushInMapInfo."
  "Point\0223\n\010vecPoint\030\004 \001(\0132!.packet.BrushIn"
  "MapInfo.PointGroup\022+\n\005range\030\005 \001(\0132\034.pack"
  "et.BrushInMapInfo.Range\032)\n\005Range\022\017\n\007maxP"
  "osX\030\003 \001(\r\022\017\n\007maxPosY\030\004 \001(\r\032M\n\005Point\022\014\n\004p"
  "osX\030\001 \001(\r\022\014\n\004posY\030\002 \001(\r\022\014\n\004rotX\030\003 \001(\r\022\014\n"
  "\004rotY\030\004 \001(\r\022\014\n\004rotZ\030\005 \001(\r\032:\n\nPointGroup\022"
  ",\n\006points\030\001 \003(\0132\034.packet.BrushInMapInfo."
  "Pointb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_map_5fcfg_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_map_5fcfg_2eproto = {
    false, false, 1253, descriptor_table_protodef_map_5fcfg_2eproto,
    "map_cfg.proto",
    &descriptor_table_map_5fcfg_2eproto_once, nullptr, 0, 10,
    schemas, file_default_instances, TableStruct_map_5fcfg_2eproto::offsets,
    file_level_metadata_map_5fcfg_2eproto, file_level_enum_descriptors_map_5fcfg_2eproto,
    file_level_service_descriptors_map_5fcfg_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_map_5fcfg_2eproto_getter() {
  return &descriptor_table_map_5fcfg_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_map_5fcfg_2eproto(&descriptor_table_map_5fcfg_2eproto);
namespace packet {

// ===================================================================

class BrushInfo_RigIdNpc_NpcUnit::_Internal {
 public:
};

BrushInfo_RigIdNpc_NpcUnit::BrushInfo_RigIdNpc_NpcUnit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInfo.RigIdNpc.NpcUnit)
}
BrushInfo_RigIdNpc_NpcUnit::BrushInfo_RigIdNpc_NpcUnit(const BrushInfo_RigIdNpc_NpcUnit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&npcid_, &from.npcid_,
    static_cast<size_t>(reinterpret_cast<char*>(&triggerareaoffsety_) -
    reinterpret_cast<char*>(&npcid_)) + sizeof(triggerareaoffsety_));
  // @@protoc_insertion_point(copy_constructor:packet.BrushInfo.RigIdNpc.NpcUnit)
}

inline void BrushInfo_RigIdNpc_NpcUnit::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&npcid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&triggerareaoffsety_) -
    reinterpret_cast<char*>(&npcid_)) + sizeof(triggerareaoffsety_));
}

BrushInfo_RigIdNpc_NpcUnit::~BrushInfo_RigIdNpc_NpcUnit() {
  // @@protoc_insertion_point(destructor:packet.BrushInfo.RigIdNpc.NpcUnit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInfo_RigIdNpc_NpcUnit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushInfo_RigIdNpc_NpcUnit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInfo_RigIdNpc_NpcUnit::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInfo.RigIdNpc.NpcUnit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&npcid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&triggerareaoffsety_) -
      reinterpret_cast<char*>(&npcid_)) + sizeof(triggerareaoffsety_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInfo_RigIdNpc_NpcUnit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 npcId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          npcid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float locationOffsetX = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          locationoffsetx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float locationOffsetY = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          locationoffsety_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotationOffsetX = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          rotationoffsetx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotationOffsetY = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          rotationoffsety_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotationOffsetZ = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          rotationoffsetz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaX = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          triggerareax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaY = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          triggerareay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaZ = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          triggerareaz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaOffsetX = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          triggerareaoffsetx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaOffsetY = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          triggerareaoffsety_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInfo_RigIdNpc_NpcUnit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInfo.RigIdNpc.NpcUnit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 npcId = 1;
  if (this->_internal_npcid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_npcid(), target);
  }

  // float locationOffsetX = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationoffsetx = this->_internal_locationoffsetx();
  uint32_t raw_locationoffsetx;
  memcpy(&raw_locationoffsetx, &tmp_locationoffsetx, sizeof(tmp_locationoffsetx));
  if (raw_locationoffsetx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_locationoffsetx(), target);
  }

  // float locationOffsetY = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationoffsety = this->_internal_locationoffsety();
  uint32_t raw_locationoffsety;
  memcpy(&raw_locationoffsety, &tmp_locationoffsety, sizeof(tmp_locationoffsety));
  if (raw_locationoffsety != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_locationoffsety(), target);
  }

  // float rotationOffsetX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsetx = this->_internal_rotationoffsetx();
  uint32_t raw_rotationoffsetx;
  memcpy(&raw_rotationoffsetx, &tmp_rotationoffsetx, sizeof(tmp_rotationoffsetx));
  if (raw_rotationoffsetx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_rotationoffsetx(), target);
  }

  // float rotationOffsetY = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsety = this->_internal_rotationoffsety();
  uint32_t raw_rotationoffsety;
  memcpy(&raw_rotationoffsety, &tmp_rotationoffsety, sizeof(tmp_rotationoffsety));
  if (raw_rotationoffsety != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_rotationoffsety(), target);
  }

  // float rotationOffsetZ = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsetz = this->_internal_rotationoffsetz();
  uint32_t raw_rotationoffsetz;
  memcpy(&raw_rotationoffsetz, &tmp_rotationoffsetz, sizeof(tmp_rotationoffsetz));
  if (raw_rotationoffsetz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_rotationoffsetz(), target);
  }

  // float triggerAreaX = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareax = this->_internal_triggerareax();
  uint32_t raw_triggerareax;
  memcpy(&raw_triggerareax, &tmp_triggerareax, sizeof(tmp_triggerareax));
  if (raw_triggerareax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_triggerareax(), target);
  }

  // float triggerAreaY = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareay = this->_internal_triggerareay();
  uint32_t raw_triggerareay;
  memcpy(&raw_triggerareay, &tmp_triggerareay, sizeof(tmp_triggerareay));
  if (raw_triggerareay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_triggerareay(), target);
  }

  // float triggerAreaZ = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaz = this->_internal_triggerareaz();
  uint32_t raw_triggerareaz;
  memcpy(&raw_triggerareaz, &tmp_triggerareaz, sizeof(tmp_triggerareaz));
  if (raw_triggerareaz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_triggerareaz(), target);
  }

  // float triggerAreaOffsetX = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsetx = this->_internal_triggerareaoffsetx();
  uint32_t raw_triggerareaoffsetx;
  memcpy(&raw_triggerareaoffsetx, &tmp_triggerareaoffsetx, sizeof(tmp_triggerareaoffsetx));
  if (raw_triggerareaoffsetx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_triggerareaoffsetx(), target);
  }

  // float triggerAreaOffsetY = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsety = this->_internal_triggerareaoffsety();
  uint32_t raw_triggerareaoffsety;
  memcpy(&raw_triggerareaoffsety, &tmp_triggerareaoffsety, sizeof(tmp_triggerareaoffsety));
  if (raw_triggerareaoffsety != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_triggerareaoffsety(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInfo.RigIdNpc.NpcUnit)
  return target;
}

size_t BrushInfo_RigIdNpc_NpcUnit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInfo.RigIdNpc.NpcUnit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 npcId = 1;
  if (this->_internal_npcid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_npcid());
  }

  // float locationOffsetX = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationoffsetx = this->_internal_locationoffsetx();
  uint32_t raw_locationoffsetx;
  memcpy(&raw_locationoffsetx, &tmp_locationoffsetx, sizeof(tmp_locationoffsetx));
  if (raw_locationoffsetx != 0) {
    total_size += 1 + 4;
  }

  // float locationOffsetY = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationoffsety = this->_internal_locationoffsety();
  uint32_t raw_locationoffsety;
  memcpy(&raw_locationoffsety, &tmp_locationoffsety, sizeof(tmp_locationoffsety));
  if (raw_locationoffsety != 0) {
    total_size += 1 + 4;
  }

  // float rotationOffsetX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsetx = this->_internal_rotationoffsetx();
  uint32_t raw_rotationoffsetx;
  memcpy(&raw_rotationoffsetx, &tmp_rotationoffsetx, sizeof(tmp_rotationoffsetx));
  if (raw_rotationoffsetx != 0) {
    total_size += 1 + 4;
  }

  // float rotationOffsetY = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsety = this->_internal_rotationoffsety();
  uint32_t raw_rotationoffsety;
  memcpy(&raw_rotationoffsety, &tmp_rotationoffsety, sizeof(tmp_rotationoffsety));
  if (raw_rotationoffsety != 0) {
    total_size += 1 + 4;
  }

  // float rotationOffsetZ = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsetz = this->_internal_rotationoffsetz();
  uint32_t raw_rotationoffsetz;
  memcpy(&raw_rotationoffsetz, &tmp_rotationoffsetz, sizeof(tmp_rotationoffsetz));
  if (raw_rotationoffsetz != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaX = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareax = this->_internal_triggerareax();
  uint32_t raw_triggerareax;
  memcpy(&raw_triggerareax, &tmp_triggerareax, sizeof(tmp_triggerareax));
  if (raw_triggerareax != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaY = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareay = this->_internal_triggerareay();
  uint32_t raw_triggerareay;
  memcpy(&raw_triggerareay, &tmp_triggerareay, sizeof(tmp_triggerareay));
  if (raw_triggerareay != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaZ = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaz = this->_internal_triggerareaz();
  uint32_t raw_triggerareaz;
  memcpy(&raw_triggerareaz, &tmp_triggerareaz, sizeof(tmp_triggerareaz));
  if (raw_triggerareaz != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaOffsetX = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsetx = this->_internal_triggerareaoffsetx();
  uint32_t raw_triggerareaoffsetx;
  memcpy(&raw_triggerareaoffsetx, &tmp_triggerareaoffsetx, sizeof(tmp_triggerareaoffsetx));
  if (raw_triggerareaoffsetx != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaOffsetY = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsety = this->_internal_triggerareaoffsety();
  uint32_t raw_triggerareaoffsety;
  memcpy(&raw_triggerareaoffsety, &tmp_triggerareaoffsety, sizeof(tmp_triggerareaoffsety));
  if (raw_triggerareaoffsety != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInfo_RigIdNpc_NpcUnit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInfo_RigIdNpc_NpcUnit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInfo_RigIdNpc_NpcUnit::GetClassData() const { return &_class_data_; }

void BrushInfo_RigIdNpc_NpcUnit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInfo_RigIdNpc_NpcUnit *>(to)->MergeFrom(
      static_cast<const BrushInfo_RigIdNpc_NpcUnit &>(from));
}


void BrushInfo_RigIdNpc_NpcUnit::MergeFrom(const BrushInfo_RigIdNpc_NpcUnit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInfo.RigIdNpc.NpcUnit)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_npcid() != 0) {
    _internal_set_npcid(from._internal_npcid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationoffsetx = from._internal_locationoffsetx();
  uint32_t raw_locationoffsetx;
  memcpy(&raw_locationoffsetx, &tmp_locationoffsetx, sizeof(tmp_locationoffsetx));
  if (raw_locationoffsetx != 0) {
    _internal_set_locationoffsetx(from._internal_locationoffsetx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationoffsety = from._internal_locationoffsety();
  uint32_t raw_locationoffsety;
  memcpy(&raw_locationoffsety, &tmp_locationoffsety, sizeof(tmp_locationoffsety));
  if (raw_locationoffsety != 0) {
    _internal_set_locationoffsety(from._internal_locationoffsety());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsetx = from._internal_rotationoffsetx();
  uint32_t raw_rotationoffsetx;
  memcpy(&raw_rotationoffsetx, &tmp_rotationoffsetx, sizeof(tmp_rotationoffsetx));
  if (raw_rotationoffsetx != 0) {
    _internal_set_rotationoffsetx(from._internal_rotationoffsetx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsety = from._internal_rotationoffsety();
  uint32_t raw_rotationoffsety;
  memcpy(&raw_rotationoffsety, &tmp_rotationoffsety, sizeof(tmp_rotationoffsety));
  if (raw_rotationoffsety != 0) {
    _internal_set_rotationoffsety(from._internal_rotationoffsety());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationoffsetz = from._internal_rotationoffsetz();
  uint32_t raw_rotationoffsetz;
  memcpy(&raw_rotationoffsetz, &tmp_rotationoffsetz, sizeof(tmp_rotationoffsetz));
  if (raw_rotationoffsetz != 0) {
    _internal_set_rotationoffsetz(from._internal_rotationoffsetz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareax = from._internal_triggerareax();
  uint32_t raw_triggerareax;
  memcpy(&raw_triggerareax, &tmp_triggerareax, sizeof(tmp_triggerareax));
  if (raw_triggerareax != 0) {
    _internal_set_triggerareax(from._internal_triggerareax());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareay = from._internal_triggerareay();
  uint32_t raw_triggerareay;
  memcpy(&raw_triggerareay, &tmp_triggerareay, sizeof(tmp_triggerareay));
  if (raw_triggerareay != 0) {
    _internal_set_triggerareay(from._internal_triggerareay());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaz = from._internal_triggerareaz();
  uint32_t raw_triggerareaz;
  memcpy(&raw_triggerareaz, &tmp_triggerareaz, sizeof(tmp_triggerareaz));
  if (raw_triggerareaz != 0) {
    _internal_set_triggerareaz(from._internal_triggerareaz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsetx = from._internal_triggerareaoffsetx();
  uint32_t raw_triggerareaoffsetx;
  memcpy(&raw_triggerareaoffsetx, &tmp_triggerareaoffsetx, sizeof(tmp_triggerareaoffsetx));
  if (raw_triggerareaoffsetx != 0) {
    _internal_set_triggerareaoffsetx(from._internal_triggerareaoffsetx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsety = from._internal_triggerareaoffsety();
  uint32_t raw_triggerareaoffsety;
  memcpy(&raw_triggerareaoffsety, &tmp_triggerareaoffsety, sizeof(tmp_triggerareaoffsety));
  if (raw_triggerareaoffsety != 0) {
    _internal_set_triggerareaoffsety(from._internal_triggerareaoffsety());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInfo_RigIdNpc_NpcUnit::CopyFrom(const BrushInfo_RigIdNpc_NpcUnit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInfo.RigIdNpc.NpcUnit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInfo_RigIdNpc_NpcUnit::IsInitialized() const {
  return true;
}

void BrushInfo_RigIdNpc_NpcUnit::InternalSwap(BrushInfo_RigIdNpc_NpcUnit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrushInfo_RigIdNpc_NpcUnit, triggerareaoffsety_)
      + sizeof(BrushInfo_RigIdNpc_NpcUnit::triggerareaoffsety_)
      - PROTOBUF_FIELD_OFFSET(BrushInfo_RigIdNpc_NpcUnit, npcid_)>(
          reinterpret_cast<char*>(&npcid_),
          reinterpret_cast<char*>(&other->npcid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInfo_RigIdNpc_NpcUnit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[0]);
}

// ===================================================================

class BrushInfo_RigIdNpc::_Internal {
 public:
};

BrushInfo_RigIdNpc::BrushInfo_RigIdNpc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  vecnpcs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInfo.RigIdNpc)
}
BrushInfo_RigIdNpc::BrushInfo_RigIdNpc(const BrushInfo_RigIdNpc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      vecnpcs_(from.vecnpcs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:packet.BrushInfo.RigIdNpc)
}

inline void BrushInfo_RigIdNpc::SharedCtor() {
}

BrushInfo_RigIdNpc::~BrushInfo_RigIdNpc() {
  // @@protoc_insertion_point(destructor:packet.BrushInfo.RigIdNpc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInfo_RigIdNpc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushInfo_RigIdNpc::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInfo_RigIdNpc::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInfo.RigIdNpc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vecnpcs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInfo_RigIdNpc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .packet.BrushInfo.RigIdNpc.NpcUnit vecNpcs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_vecnpcs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInfo_RigIdNpc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInfo.RigIdNpc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .packet.BrushInfo.RigIdNpc.NpcUnit vecNpcs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_vecnpcs_size()); i < n; i++) {
    const auto& repfield = this->_internal_vecnpcs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInfo.RigIdNpc)
  return target;
}

size_t BrushInfo_RigIdNpc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInfo.RigIdNpc)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .packet.BrushInfo.RigIdNpc.NpcUnit vecNpcs = 1;
  total_size += 1UL * this->_internal_vecnpcs_size();
  for (const auto& msg : this->vecnpcs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInfo_RigIdNpc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInfo_RigIdNpc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInfo_RigIdNpc::GetClassData() const { return &_class_data_; }

void BrushInfo_RigIdNpc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInfo_RigIdNpc *>(to)->MergeFrom(
      static_cast<const BrushInfo_RigIdNpc &>(from));
}


void BrushInfo_RigIdNpc::MergeFrom(const BrushInfo_RigIdNpc& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInfo.RigIdNpc)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  vecnpcs_.MergeFrom(from.vecnpcs_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInfo_RigIdNpc::CopyFrom(const BrushInfo_RigIdNpc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInfo.RigIdNpc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInfo_RigIdNpc::IsInitialized() const {
  return true;
}

void BrushInfo_RigIdNpc::InternalSwap(BrushInfo_RigIdNpc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  vecnpcs_.InternalSwap(&other->vecnpcs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInfo_RigIdNpc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[1]);
}

// ===================================================================

class BrushInfo_Teleporter::_Internal {
 public:
};

BrushInfo_Teleporter::BrushInfo_Teleporter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInfo.Teleporter)
}
BrushInfo_Teleporter::BrushInfo_Teleporter(const BrushInfo_Teleporter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&teleporttype_, &from.teleporttype_,
    static_cast<size_t>(reinterpret_cast<char*>(&teleportanim_) -
    reinterpret_cast<char*>(&teleporttype_)) + sizeof(teleportanim_));
  // @@protoc_insertion_point(copy_constructor:packet.BrushInfo.Teleporter)
}

inline void BrushInfo_Teleporter::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&teleporttype_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&teleportanim_) -
    reinterpret_cast<char*>(&teleporttype_)) + sizeof(teleportanim_));
}

BrushInfo_Teleporter::~BrushInfo_Teleporter() {
  // @@protoc_insertion_point(destructor:packet.BrushInfo.Teleporter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInfo_Teleporter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushInfo_Teleporter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInfo_Teleporter::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInfo.Teleporter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&teleporttype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&teleportanim_) -
      reinterpret_cast<char*>(&teleporttype_)) + sizeof(teleportanim_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInfo_Teleporter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 teleportType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          teleporttype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 targetMap = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          targetmap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float locationX = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          locationx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float locationY = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          locationy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotationX = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          rotationx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotationY = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          rotationy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotationZ = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          rotationz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaX = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          triggerareax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaY = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          triggerareay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaZ = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          triggerareaz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaOffsetX = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          triggerareaoffsetx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float triggerAreaOffsetY = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          triggerareaoffsety_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 teleportAnim = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          teleportanim_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInfo_Teleporter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInfo.Teleporter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 teleportType = 1;
  if (this->_internal_teleporttype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_teleporttype(), target);
  }

  // uint32 targetMap = 2;
  if (this->_internal_targetmap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_targetmap(), target);
  }

  // float locationX = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationx = this->_internal_locationx();
  uint32_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_locationx(), target);
  }

  // float locationY = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationy = this->_internal_locationy();
  uint32_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_locationy(), target);
  }

  // float rotationX = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationx = this->_internal_rotationx();
  uint32_t raw_rotationx;
  memcpy(&raw_rotationx, &tmp_rotationx, sizeof(tmp_rotationx));
  if (raw_rotationx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_rotationx(), target);
  }

  // float rotationY = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationy = this->_internal_rotationy();
  uint32_t raw_rotationy;
  memcpy(&raw_rotationy, &tmp_rotationy, sizeof(tmp_rotationy));
  if (raw_rotationy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_rotationy(), target);
  }

  // float rotationZ = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationz = this->_internal_rotationz();
  uint32_t raw_rotationz;
  memcpy(&raw_rotationz, &tmp_rotationz, sizeof(tmp_rotationz));
  if (raw_rotationz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_rotationz(), target);
  }

  // float triggerAreaX = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareax = this->_internal_triggerareax();
  uint32_t raw_triggerareax;
  memcpy(&raw_triggerareax, &tmp_triggerareax, sizeof(tmp_triggerareax));
  if (raw_triggerareax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_triggerareax(), target);
  }

  // float triggerAreaY = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareay = this->_internal_triggerareay();
  uint32_t raw_triggerareay;
  memcpy(&raw_triggerareay, &tmp_triggerareay, sizeof(tmp_triggerareay));
  if (raw_triggerareay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_triggerareay(), target);
  }

  // float triggerAreaZ = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaz = this->_internal_triggerareaz();
  uint32_t raw_triggerareaz;
  memcpy(&raw_triggerareaz, &tmp_triggerareaz, sizeof(tmp_triggerareaz));
  if (raw_triggerareaz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_triggerareaz(), target);
  }

  // float triggerAreaOffsetX = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsetx = this->_internal_triggerareaoffsetx();
  uint32_t raw_triggerareaoffsetx;
  memcpy(&raw_triggerareaoffsetx, &tmp_triggerareaoffsetx, sizeof(tmp_triggerareaoffsetx));
  if (raw_triggerareaoffsetx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_triggerareaoffsetx(), target);
  }

  // float triggerAreaOffsetY = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsety = this->_internal_triggerareaoffsety();
  uint32_t raw_triggerareaoffsety;
  memcpy(&raw_triggerareaoffsety, &tmp_triggerareaoffsety, sizeof(tmp_triggerareaoffsety));
  if (raw_triggerareaoffsety != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_triggerareaoffsety(), target);
  }

  // uint32 teleportAnim = 13;
  if (this->_internal_teleportanim() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_teleportanim(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInfo.Teleporter)
  return target;
}

size_t BrushInfo_Teleporter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInfo.Teleporter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 teleportType = 1;
  if (this->_internal_teleporttype() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_teleporttype());
  }

  // uint32 targetMap = 2;
  if (this->_internal_targetmap() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_targetmap());
  }

  // float locationX = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationx = this->_internal_locationx();
  uint32_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    total_size += 1 + 4;
  }

  // float locationY = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationy = this->_internal_locationy();
  uint32_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    total_size += 1 + 4;
  }

  // float rotationX = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationx = this->_internal_rotationx();
  uint32_t raw_rotationx;
  memcpy(&raw_rotationx, &tmp_rotationx, sizeof(tmp_rotationx));
  if (raw_rotationx != 0) {
    total_size += 1 + 4;
  }

  // float rotationY = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationy = this->_internal_rotationy();
  uint32_t raw_rotationy;
  memcpy(&raw_rotationy, &tmp_rotationy, sizeof(tmp_rotationy));
  if (raw_rotationy != 0) {
    total_size += 1 + 4;
  }

  // float rotationZ = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationz = this->_internal_rotationz();
  uint32_t raw_rotationz;
  memcpy(&raw_rotationz, &tmp_rotationz, sizeof(tmp_rotationz));
  if (raw_rotationz != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaX = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareax = this->_internal_triggerareax();
  uint32_t raw_triggerareax;
  memcpy(&raw_triggerareax, &tmp_triggerareax, sizeof(tmp_triggerareax));
  if (raw_triggerareax != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaY = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareay = this->_internal_triggerareay();
  uint32_t raw_triggerareay;
  memcpy(&raw_triggerareay, &tmp_triggerareay, sizeof(tmp_triggerareay));
  if (raw_triggerareay != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaZ = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaz = this->_internal_triggerareaz();
  uint32_t raw_triggerareaz;
  memcpy(&raw_triggerareaz, &tmp_triggerareaz, sizeof(tmp_triggerareaz));
  if (raw_triggerareaz != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaOffsetX = 11;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsetx = this->_internal_triggerareaoffsetx();
  uint32_t raw_triggerareaoffsetx;
  memcpy(&raw_triggerareaoffsetx, &tmp_triggerareaoffsetx, sizeof(tmp_triggerareaoffsetx));
  if (raw_triggerareaoffsetx != 0) {
    total_size += 1 + 4;
  }

  // float triggerAreaOffsetY = 12;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsety = this->_internal_triggerareaoffsety();
  uint32_t raw_triggerareaoffsety;
  memcpy(&raw_triggerareaoffsety, &tmp_triggerareaoffsety, sizeof(tmp_triggerareaoffsety));
  if (raw_triggerareaoffsety != 0) {
    total_size += 1 + 4;
  }

  // uint32 teleportAnim = 13;
  if (this->_internal_teleportanim() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_teleportanim());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInfo_Teleporter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInfo_Teleporter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInfo_Teleporter::GetClassData() const { return &_class_data_; }

void BrushInfo_Teleporter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInfo_Teleporter *>(to)->MergeFrom(
      static_cast<const BrushInfo_Teleporter &>(from));
}


void BrushInfo_Teleporter::MergeFrom(const BrushInfo_Teleporter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInfo.Teleporter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_teleporttype() != 0) {
    _internal_set_teleporttype(from._internal_teleporttype());
  }
  if (from._internal_targetmap() != 0) {
    _internal_set_targetmap(from._internal_targetmap());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationx = from._internal_locationx();
  uint32_t raw_locationx;
  memcpy(&raw_locationx, &tmp_locationx, sizeof(tmp_locationx));
  if (raw_locationx != 0) {
    _internal_set_locationx(from._internal_locationx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_locationy = from._internal_locationy();
  uint32_t raw_locationy;
  memcpy(&raw_locationy, &tmp_locationy, sizeof(tmp_locationy));
  if (raw_locationy != 0) {
    _internal_set_locationy(from._internal_locationy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationx = from._internal_rotationx();
  uint32_t raw_rotationx;
  memcpy(&raw_rotationx, &tmp_rotationx, sizeof(tmp_rotationx));
  if (raw_rotationx != 0) {
    _internal_set_rotationx(from._internal_rotationx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationy = from._internal_rotationy();
  uint32_t raw_rotationy;
  memcpy(&raw_rotationy, &tmp_rotationy, sizeof(tmp_rotationy));
  if (raw_rotationy != 0) {
    _internal_set_rotationy(from._internal_rotationy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotationz = from._internal_rotationz();
  uint32_t raw_rotationz;
  memcpy(&raw_rotationz, &tmp_rotationz, sizeof(tmp_rotationz));
  if (raw_rotationz != 0) {
    _internal_set_rotationz(from._internal_rotationz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareax = from._internal_triggerareax();
  uint32_t raw_triggerareax;
  memcpy(&raw_triggerareax, &tmp_triggerareax, sizeof(tmp_triggerareax));
  if (raw_triggerareax != 0) {
    _internal_set_triggerareax(from._internal_triggerareax());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareay = from._internal_triggerareay();
  uint32_t raw_triggerareay;
  memcpy(&raw_triggerareay, &tmp_triggerareay, sizeof(tmp_triggerareay));
  if (raw_triggerareay != 0) {
    _internal_set_triggerareay(from._internal_triggerareay());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaz = from._internal_triggerareaz();
  uint32_t raw_triggerareaz;
  memcpy(&raw_triggerareaz, &tmp_triggerareaz, sizeof(tmp_triggerareaz));
  if (raw_triggerareaz != 0) {
    _internal_set_triggerareaz(from._internal_triggerareaz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsetx = from._internal_triggerareaoffsetx();
  uint32_t raw_triggerareaoffsetx;
  memcpy(&raw_triggerareaoffsetx, &tmp_triggerareaoffsetx, sizeof(tmp_triggerareaoffsetx));
  if (raw_triggerareaoffsetx != 0) {
    _internal_set_triggerareaoffsetx(from._internal_triggerareaoffsetx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_triggerareaoffsety = from._internal_triggerareaoffsety();
  uint32_t raw_triggerareaoffsety;
  memcpy(&raw_triggerareaoffsety, &tmp_triggerareaoffsety, sizeof(tmp_triggerareaoffsety));
  if (raw_triggerareaoffsety != 0) {
    _internal_set_triggerareaoffsety(from._internal_triggerareaoffsety());
  }
  if (from._internal_teleportanim() != 0) {
    _internal_set_teleportanim(from._internal_teleportanim());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInfo_Teleporter::CopyFrom(const BrushInfo_Teleporter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInfo.Teleporter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInfo_Teleporter::IsInitialized() const {
  return true;
}

void BrushInfo_Teleporter::InternalSwap(BrushInfo_Teleporter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrushInfo_Teleporter, teleportanim_)
      + sizeof(BrushInfo_Teleporter::teleportanim_)
      - PROTOBUF_FIELD_OFFSET(BrushInfo_Teleporter, teleporttype_)>(
          reinterpret_cast<char*>(&teleporttype_),
          reinterpret_cast<char*>(&other->teleporttype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInfo_Teleporter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[2]);
}

// ===================================================================

class BrushInfo_BlockArea::_Internal {
 public:
};

BrushInfo_BlockArea::BrushInfo_BlockArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInfo.BlockArea)
}
BrushInfo_BlockArea::BrushInfo_BlockArea(const BrushInfo_BlockArea& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&blockareaid_, &from.blockareaid_,
    static_cast<size_t>(reinterpret_cast<char*>(&blockareaoffsety_) -
    reinterpret_cast<char*>(&blockareaid_)) + sizeof(blockareaoffsety_));
  // @@protoc_insertion_point(copy_constructor:packet.BrushInfo.BlockArea)
}

inline void BrushInfo_BlockArea::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&blockareaid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&blockareaoffsety_) -
    reinterpret_cast<char*>(&blockareaid_)) + sizeof(blockareaoffsety_));
}

BrushInfo_BlockArea::~BrushInfo_BlockArea() {
  // @@protoc_insertion_point(destructor:packet.BrushInfo.BlockArea)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInfo_BlockArea::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushInfo_BlockArea::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInfo_BlockArea::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInfo.BlockArea)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&blockareaid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&blockareaoffsety_) -
      reinterpret_cast<char*>(&blockareaid_)) + sizeof(blockareaoffsety_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInfo_BlockArea::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 blockAreaId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          blockareaid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float blockAreaX = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          blockareax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float blockAreaY = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          blockareay_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float blockAreaZ = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          blockareaz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float blockAreaOffsetX = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          blockareaoffsetx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float blockAreaOffsetY = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          blockareaoffsety_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInfo_BlockArea::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInfo.BlockArea)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 blockAreaId = 1;
  if (this->_internal_blockareaid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_blockareaid(), target);
  }

  // float blockAreaX = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareax = this->_internal_blockareax();
  uint32_t raw_blockareax;
  memcpy(&raw_blockareax, &tmp_blockareax, sizeof(tmp_blockareax));
  if (raw_blockareax != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_blockareax(), target);
  }

  // float blockAreaY = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareay = this->_internal_blockareay();
  uint32_t raw_blockareay;
  memcpy(&raw_blockareay, &tmp_blockareay, sizeof(tmp_blockareay));
  if (raw_blockareay != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_blockareay(), target);
  }

  // float blockAreaZ = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaz = this->_internal_blockareaz();
  uint32_t raw_blockareaz;
  memcpy(&raw_blockareaz, &tmp_blockareaz, sizeof(tmp_blockareaz));
  if (raw_blockareaz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_blockareaz(), target);
  }

  // float blockAreaOffsetX = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaoffsetx = this->_internal_blockareaoffsetx();
  uint32_t raw_blockareaoffsetx;
  memcpy(&raw_blockareaoffsetx, &tmp_blockareaoffsetx, sizeof(tmp_blockareaoffsetx));
  if (raw_blockareaoffsetx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_blockareaoffsetx(), target);
  }

  // float blockAreaOffsetY = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaoffsety = this->_internal_blockareaoffsety();
  uint32_t raw_blockareaoffsety;
  memcpy(&raw_blockareaoffsety, &tmp_blockareaoffsety, sizeof(tmp_blockareaoffsety));
  if (raw_blockareaoffsety != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_blockareaoffsety(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInfo.BlockArea)
  return target;
}

size_t BrushInfo_BlockArea::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInfo.BlockArea)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 blockAreaId = 1;
  if (this->_internal_blockareaid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blockareaid());
  }

  // float blockAreaX = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareax = this->_internal_blockareax();
  uint32_t raw_blockareax;
  memcpy(&raw_blockareax, &tmp_blockareax, sizeof(tmp_blockareax));
  if (raw_blockareax != 0) {
    total_size += 1 + 4;
  }

  // float blockAreaY = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareay = this->_internal_blockareay();
  uint32_t raw_blockareay;
  memcpy(&raw_blockareay, &tmp_blockareay, sizeof(tmp_blockareay));
  if (raw_blockareay != 0) {
    total_size += 1 + 4;
  }

  // float blockAreaZ = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaz = this->_internal_blockareaz();
  uint32_t raw_blockareaz;
  memcpy(&raw_blockareaz, &tmp_blockareaz, sizeof(tmp_blockareaz));
  if (raw_blockareaz != 0) {
    total_size += 1 + 4;
  }

  // float blockAreaOffsetX = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaoffsetx = this->_internal_blockareaoffsetx();
  uint32_t raw_blockareaoffsetx;
  memcpy(&raw_blockareaoffsetx, &tmp_blockareaoffsetx, sizeof(tmp_blockareaoffsetx));
  if (raw_blockareaoffsetx != 0) {
    total_size += 1 + 4;
  }

  // float blockAreaOffsetY = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaoffsety = this->_internal_blockareaoffsety();
  uint32_t raw_blockareaoffsety;
  memcpy(&raw_blockareaoffsety, &tmp_blockareaoffsety, sizeof(tmp_blockareaoffsety));
  if (raw_blockareaoffsety != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInfo_BlockArea::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInfo_BlockArea::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInfo_BlockArea::GetClassData() const { return &_class_data_; }

void BrushInfo_BlockArea::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInfo_BlockArea *>(to)->MergeFrom(
      static_cast<const BrushInfo_BlockArea &>(from));
}


void BrushInfo_BlockArea::MergeFrom(const BrushInfo_BlockArea& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInfo.BlockArea)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_blockareaid() != 0) {
    _internal_set_blockareaid(from._internal_blockareaid());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareax = from._internal_blockareax();
  uint32_t raw_blockareax;
  memcpy(&raw_blockareax, &tmp_blockareax, sizeof(tmp_blockareax));
  if (raw_blockareax != 0) {
    _internal_set_blockareax(from._internal_blockareax());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareay = from._internal_blockareay();
  uint32_t raw_blockareay;
  memcpy(&raw_blockareay, &tmp_blockareay, sizeof(tmp_blockareay));
  if (raw_blockareay != 0) {
    _internal_set_blockareay(from._internal_blockareay());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaz = from._internal_blockareaz();
  uint32_t raw_blockareaz;
  memcpy(&raw_blockareaz, &tmp_blockareaz, sizeof(tmp_blockareaz));
  if (raw_blockareaz != 0) {
    _internal_set_blockareaz(from._internal_blockareaz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaoffsetx = from._internal_blockareaoffsetx();
  uint32_t raw_blockareaoffsetx;
  memcpy(&raw_blockareaoffsetx, &tmp_blockareaoffsetx, sizeof(tmp_blockareaoffsetx));
  if (raw_blockareaoffsetx != 0) {
    _internal_set_blockareaoffsetx(from._internal_blockareaoffsetx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blockareaoffsety = from._internal_blockareaoffsety();
  uint32_t raw_blockareaoffsety;
  memcpy(&raw_blockareaoffsety, &tmp_blockareaoffsety, sizeof(tmp_blockareaoffsety));
  if (raw_blockareaoffsety != 0) {
    _internal_set_blockareaoffsety(from._internal_blockareaoffsety());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInfo_BlockArea::CopyFrom(const BrushInfo_BlockArea& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInfo.BlockArea)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInfo_BlockArea::IsInitialized() const {
  return true;
}

void BrushInfo_BlockArea::InternalSwap(BrushInfo_BlockArea* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrushInfo_BlockArea, blockareaoffsety_)
      + sizeof(BrushInfo_BlockArea::blockareaoffsety_)
      - PROTOBUF_FIELD_OFFSET(BrushInfo_BlockArea, blockareaid_)>(
          reinterpret_cast<char*>(&blockareaid_),
          reinterpret_cast<char*>(&other->blockareaid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInfo_BlockArea::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[3]);
}

// ===================================================================

class BrushInfo::_Internal {
 public:
};

BrushInfo::BrushInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:packet.BrushInfo)
}
BrushInfo::BrushInfo(const BrushInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:packet.BrushInfo)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInfo::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata BrushInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[4]);
}

// ===================================================================

class BrushAll::_Internal {
 public:
};

BrushAll::BrushAll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  brushinfos_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushAll)
}
BrushAll::BrushAll(const BrushAll& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      brushinfos_(from.brushinfos_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:packet.BrushAll)
}

inline void BrushAll::SharedCtor() {
}

BrushAll::~BrushAll() {
  // @@protoc_insertion_point(destructor:packet.BrushAll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushAll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushAll::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushAll::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushAll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  brushinfos_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushAll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .packet.BrushInfo brushInfos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_brushinfos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushAll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushAll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .packet.BrushInfo brushInfos = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_brushinfos_size()); i < n; i++) {
    const auto& repfield = this->_internal_brushinfos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushAll)
  return target;
}

size_t BrushAll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushAll)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .packet.BrushInfo brushInfos = 1;
  total_size += 1UL * this->_internal_brushinfos_size();
  for (const auto& msg : this->brushinfos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushAll::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushAll::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushAll::GetClassData() const { return &_class_data_; }

void BrushAll::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushAll *>(to)->MergeFrom(
      static_cast<const BrushAll &>(from));
}


void BrushAll::MergeFrom(const BrushAll& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushAll)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  brushinfos_.MergeFrom(from.brushinfos_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushAll::CopyFrom(const BrushAll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushAll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushAll::IsInitialized() const {
  return true;
}

void BrushAll::InternalSwap(BrushAll* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  brushinfos_.InternalSwap(&other->brushinfos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushAll::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[5]);
}

// ===================================================================

class BrushInMapInfo_Range::_Internal {
 public:
};

BrushInMapInfo_Range::BrushInMapInfo_Range(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInMapInfo.Range)
}
BrushInMapInfo_Range::BrushInMapInfo_Range(const BrushInMapInfo_Range& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&maxposx_, &from.maxposx_,
    static_cast<size_t>(reinterpret_cast<char*>(&maxposy_) -
    reinterpret_cast<char*>(&maxposx_)) + sizeof(maxposy_));
  // @@protoc_insertion_point(copy_constructor:packet.BrushInMapInfo.Range)
}

inline void BrushInMapInfo_Range::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&maxposx_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&maxposy_) -
    reinterpret_cast<char*>(&maxposx_)) + sizeof(maxposy_));
}

BrushInMapInfo_Range::~BrushInMapInfo_Range() {
  // @@protoc_insertion_point(destructor:packet.BrushInMapInfo.Range)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInMapInfo_Range::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushInMapInfo_Range::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInMapInfo_Range::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInMapInfo.Range)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&maxposx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&maxposy_) -
      reinterpret_cast<char*>(&maxposx_)) + sizeof(maxposy_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInMapInfo_Range::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 maxPosX = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          maxposx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 maxPosY = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          maxposy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInMapInfo_Range::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInMapInfo.Range)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 maxPosX = 3;
  if (this->_internal_maxposx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_maxposx(), target);
  }

  // uint32 maxPosY = 4;
  if (this->_internal_maxposy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_maxposy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInMapInfo.Range)
  return target;
}

size_t BrushInMapInfo_Range::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInMapInfo.Range)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 maxPosX = 3;
  if (this->_internal_maxposx() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxposx());
  }

  // uint32 maxPosY = 4;
  if (this->_internal_maxposy() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maxposy());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInMapInfo_Range::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInMapInfo_Range::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInMapInfo_Range::GetClassData() const { return &_class_data_; }

void BrushInMapInfo_Range::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInMapInfo_Range *>(to)->MergeFrom(
      static_cast<const BrushInMapInfo_Range &>(from));
}


void BrushInMapInfo_Range::MergeFrom(const BrushInMapInfo_Range& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInMapInfo.Range)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_maxposx() != 0) {
    _internal_set_maxposx(from._internal_maxposx());
  }
  if (from._internal_maxposy() != 0) {
    _internal_set_maxposy(from._internal_maxposy());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInMapInfo_Range::CopyFrom(const BrushInMapInfo_Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInMapInfo.Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInMapInfo_Range::IsInitialized() const {
  return true;
}

void BrushInMapInfo_Range::InternalSwap(BrushInMapInfo_Range* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrushInMapInfo_Range, maxposy_)
      + sizeof(BrushInMapInfo_Range::maxposy_)
      - PROTOBUF_FIELD_OFFSET(BrushInMapInfo_Range, maxposx_)>(
          reinterpret_cast<char*>(&maxposx_),
          reinterpret_cast<char*>(&other->maxposx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInMapInfo_Range::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[6]);
}

// ===================================================================

class BrushInMapInfo_Point::_Internal {
 public:
};

BrushInMapInfo_Point::BrushInMapInfo_Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInMapInfo.Point)
}
BrushInMapInfo_Point::BrushInMapInfo_Point(const BrushInMapInfo_Point& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&posx_, &from.posx_,
    static_cast<size_t>(reinterpret_cast<char*>(&rotz_) -
    reinterpret_cast<char*>(&posx_)) + sizeof(rotz_));
  // @@protoc_insertion_point(copy_constructor:packet.BrushInMapInfo.Point)
}

inline void BrushInMapInfo_Point::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&posx_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rotz_) -
    reinterpret_cast<char*>(&posx_)) + sizeof(rotz_));
}

BrushInMapInfo_Point::~BrushInMapInfo_Point() {
  // @@protoc_insertion_point(destructor:packet.BrushInMapInfo.Point)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInMapInfo_Point::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushInMapInfo_Point::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInMapInfo_Point::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInMapInfo.Point)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&posx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rotz_) -
      reinterpret_cast<char*>(&posx_)) + sizeof(rotz_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInMapInfo_Point::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 posX = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          posx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 posY = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          posy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 rotX = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          rotx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 rotY = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          roty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 rotZ = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          rotz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInMapInfo_Point::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInMapInfo.Point)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 posX = 1;
  if (this->_internal_posx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_posx(), target);
  }

  // uint32 posY = 2;
  if (this->_internal_posy() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_posy(), target);
  }

  // uint32 rotX = 3;
  if (this->_internal_rotx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_rotx(), target);
  }

  // uint32 rotY = 4;
  if (this->_internal_roty() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_roty(), target);
  }

  // uint32 rotZ = 5;
  if (this->_internal_rotz() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_rotz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInMapInfo.Point)
  return target;
}

size_t BrushInMapInfo_Point::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInMapInfo.Point)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 posX = 1;
  if (this->_internal_posx() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_posx());
  }

  // uint32 posY = 2;
  if (this->_internal_posy() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_posy());
  }

  // uint32 rotX = 3;
  if (this->_internal_rotx() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rotx());
  }

  // uint32 rotY = 4;
  if (this->_internal_roty() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_roty());
  }

  // uint32 rotZ = 5;
  if (this->_internal_rotz() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rotz());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInMapInfo_Point::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInMapInfo_Point::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInMapInfo_Point::GetClassData() const { return &_class_data_; }

void BrushInMapInfo_Point::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInMapInfo_Point *>(to)->MergeFrom(
      static_cast<const BrushInMapInfo_Point &>(from));
}


void BrushInMapInfo_Point::MergeFrom(const BrushInMapInfo_Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInMapInfo.Point)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_posx() != 0) {
    _internal_set_posx(from._internal_posx());
  }
  if (from._internal_posy() != 0) {
    _internal_set_posy(from._internal_posy());
  }
  if (from._internal_rotx() != 0) {
    _internal_set_rotx(from._internal_rotx());
  }
  if (from._internal_roty() != 0) {
    _internal_set_roty(from._internal_roty());
  }
  if (from._internal_rotz() != 0) {
    _internal_set_rotz(from._internal_rotz());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInMapInfo_Point::CopyFrom(const BrushInMapInfo_Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInMapInfo.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInMapInfo_Point::IsInitialized() const {
  return true;
}

void BrushInMapInfo_Point::InternalSwap(BrushInMapInfo_Point* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrushInMapInfo_Point, rotz_)
      + sizeof(BrushInMapInfo_Point::rotz_)
      - PROTOBUF_FIELD_OFFSET(BrushInMapInfo_Point, posx_)>(
          reinterpret_cast<char*>(&posx_),
          reinterpret_cast<char*>(&other->posx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInMapInfo_Point::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[7]);
}

// ===================================================================

class BrushInMapInfo_PointGroup::_Internal {
 public:
};

BrushInMapInfo_PointGroup::BrushInMapInfo_PointGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  points_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInMapInfo.PointGroup)
}
BrushInMapInfo_PointGroup::BrushInMapInfo_PointGroup(const BrushInMapInfo_PointGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      points_(from.points_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:packet.BrushInMapInfo.PointGroup)
}

inline void BrushInMapInfo_PointGroup::SharedCtor() {
}

BrushInMapInfo_PointGroup::~BrushInMapInfo_PointGroup() {
  // @@protoc_insertion_point(destructor:packet.BrushInMapInfo.PointGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInMapInfo_PointGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BrushInMapInfo_PointGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInMapInfo_PointGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInMapInfo.PointGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  points_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInMapInfo_PointGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .packet.BrushInMapInfo.Point points = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInMapInfo_PointGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInMapInfo.PointGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .packet.BrushInMapInfo.Point points = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInMapInfo.PointGroup)
  return target;
}

size_t BrushInMapInfo_PointGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInMapInfo.PointGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .packet.BrushInMapInfo.Point points = 1;
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInMapInfo_PointGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInMapInfo_PointGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInMapInfo_PointGroup::GetClassData() const { return &_class_data_; }

void BrushInMapInfo_PointGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInMapInfo_PointGroup *>(to)->MergeFrom(
      static_cast<const BrushInMapInfo_PointGroup &>(from));
}


void BrushInMapInfo_PointGroup::MergeFrom(const BrushInMapInfo_PointGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInMapInfo.PointGroup)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  points_.MergeFrom(from.points_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInMapInfo_PointGroup::CopyFrom(const BrushInMapInfo_PointGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInMapInfo.PointGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInMapInfo_PointGroup::IsInitialized() const {
  return true;
}

void BrushInMapInfo_PointGroup::InternalSwap(BrushInMapInfo_PointGroup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  points_.InternalSwap(&other->points_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInMapInfo_PointGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[8]);
}

// ===================================================================

class BrushInMapInfo::_Internal {
 public:
  static const ::packet::BrushInMapInfo_Point& point(const BrushInMapInfo* msg);
  static const ::packet::BrushInMapInfo_PointGroup& vecpoint(const BrushInMapInfo* msg);
  static const ::packet::BrushInMapInfo_Range& range(const BrushInMapInfo* msg);
};

const ::packet::BrushInMapInfo_Point&
BrushInMapInfo::_Internal::point(const BrushInMapInfo* msg) {
  return *msg->point_;
}
const ::packet::BrushInMapInfo_PointGroup&
BrushInMapInfo::_Internal::vecpoint(const BrushInMapInfo* msg) {
  return *msg->vecpoint_;
}
const ::packet::BrushInMapInfo_Range&
BrushInMapInfo::_Internal::range(const BrushInMapInfo* msg) {
  return *msg->range_;
}
BrushInMapInfo::BrushInMapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:packet.BrushInMapInfo)
}
BrushInMapInfo::BrushInMapInfo(const BrushInMapInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_point()) {
    point_ = new ::packet::BrushInMapInfo_Point(*from.point_);
  } else {
    point_ = nullptr;
  }
  if (from._internal_has_vecpoint()) {
    vecpoint_ = new ::packet::BrushInMapInfo_PointGroup(*from.vecpoint_);
  } else {
    vecpoint_ = nullptr;
  }
  if (from._internal_has_range()) {
    range_ = new ::packet::BrushInMapInfo_Range(*from.range_);
  } else {
    range_ = nullptr;
  }
  ::memcpy(&brushid_, &from.brushid_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&brushid_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:packet.BrushInMapInfo)
}

inline void BrushInMapInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&point_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&point_)) + sizeof(type_));
}

BrushInMapInfo::~BrushInMapInfo() {
  // @@protoc_insertion_point(destructor:packet.BrushInMapInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BrushInMapInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete point_;
  if (this != internal_default_instance()) delete vecpoint_;
  if (this != internal_default_instance()) delete range_;
}

void BrushInMapInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BrushInMapInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:packet.BrushInMapInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && point_ != nullptr) {
    delete point_;
  }
  point_ = nullptr;
  if (GetArenaForAllocation() == nullptr && vecpoint_ != nullptr) {
    delete vecpoint_;
  }
  vecpoint_ = nullptr;
  if (GetArenaForAllocation() == nullptr && range_ != nullptr) {
    delete range_;
  }
  range_ = nullptr;
  ::memset(&brushid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&brushid_)) + sizeof(type_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BrushInMapInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 brushId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          brushid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .packet.BrushInMapInfo.Point point = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_point(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .packet.BrushInMapInfo.PointGroup vecPoint = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_vecpoint(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .packet.BrushInMapInfo.Range range = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_range(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BrushInMapInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:packet.BrushInMapInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_type(), target);
  }

  // uint64 brushId = 2;
  if (this->_internal_brushid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_brushid(), target);
  }

  // .packet.BrushInMapInfo.Point point = 3;
  if (this->_internal_has_point()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::point(this),
        _Internal::point(this).GetCachedSize(), target, stream);
  }

  // .packet.BrushInMapInfo.PointGroup vecPoint = 4;
  if (this->_internal_has_vecpoint()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::vecpoint(this),
        _Internal::vecpoint(this).GetCachedSize(), target, stream);
  }

  // .packet.BrushInMapInfo.Range range = 5;
  if (this->_internal_has_range()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::range(this),
        _Internal::range(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:packet.BrushInMapInfo)
  return target;
}

size_t BrushInMapInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:packet.BrushInMapInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .packet.BrushInMapInfo.Point point = 3;
  if (this->_internal_has_point()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *point_);
  }

  // .packet.BrushInMapInfo.PointGroup vecPoint = 4;
  if (this->_internal_has_vecpoint()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *vecpoint_);
  }

  // .packet.BrushInMapInfo.Range range = 5;
  if (this->_internal_has_range()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *range_);
  }

  // uint64 brushId = 2;
  if (this->_internal_brushid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_brushid());
  }

  // uint32 type = 1;
  if (this->_internal_type() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BrushInMapInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BrushInMapInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BrushInMapInfo::GetClassData() const { return &_class_data_; }

void BrushInMapInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BrushInMapInfo *>(to)->MergeFrom(
      static_cast<const BrushInMapInfo &>(from));
}


void BrushInMapInfo::MergeFrom(const BrushInMapInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:packet.BrushInMapInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_point()) {
    _internal_mutable_point()->::packet::BrushInMapInfo_Point::MergeFrom(from._internal_point());
  }
  if (from._internal_has_vecpoint()) {
    _internal_mutable_vecpoint()->::packet::BrushInMapInfo_PointGroup::MergeFrom(from._internal_vecpoint());
  }
  if (from._internal_has_range()) {
    _internal_mutable_range()->::packet::BrushInMapInfo_Range::MergeFrom(from._internal_range());
  }
  if (from._internal_brushid() != 0) {
    _internal_set_brushid(from._internal_brushid());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BrushInMapInfo::CopyFrom(const BrushInMapInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:packet.BrushInMapInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BrushInMapInfo::IsInitialized() const {
  return true;
}

void BrushInMapInfo::InternalSwap(BrushInMapInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BrushInMapInfo, type_)
      + sizeof(BrushInMapInfo::type_)
      - PROTOBUF_FIELD_OFFSET(BrushInMapInfo, point_)>(
          reinterpret_cast<char*>(&point_),
          reinterpret_cast<char*>(&other->point_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BrushInMapInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_map_5fcfg_2eproto_getter, &descriptor_table_map_5fcfg_2eproto_once,
      file_level_metadata_map_5fcfg_2eproto[9]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace packet
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::packet::BrushInfo_RigIdNpc_NpcUnit*
Arena::CreateMaybeMessage< ::packet::BrushInfo_RigIdNpc_NpcUnit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInfo_RigIdNpc_NpcUnit >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInfo_RigIdNpc*
Arena::CreateMaybeMessage< ::packet::BrushInfo_RigIdNpc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInfo_RigIdNpc >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInfo_Teleporter*
Arena::CreateMaybeMessage< ::packet::BrushInfo_Teleporter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInfo_Teleporter >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInfo_BlockArea*
Arena::CreateMaybeMessage< ::packet::BrushInfo_BlockArea >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInfo_BlockArea >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInfo*
Arena::CreateMaybeMessage< ::packet::BrushInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushAll*
Arena::CreateMaybeMessage< ::packet::BrushAll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushAll >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInMapInfo_Range*
Arena::CreateMaybeMessage< ::packet::BrushInMapInfo_Range >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInMapInfo_Range >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInMapInfo_Point*
Arena::CreateMaybeMessage< ::packet::BrushInMapInfo_Point >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInMapInfo_Point >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInMapInfo_PointGroup*
Arena::CreateMaybeMessage< ::packet::BrushInMapInfo_PointGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInMapInfo_PointGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::packet::BrushInMapInfo*
Arena::CreateMaybeMessage< ::packet::BrushInMapInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::packet::BrushInMapInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
