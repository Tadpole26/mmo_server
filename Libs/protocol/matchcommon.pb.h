// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: matchcommon.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_matchcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_matchcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "fight3v3common.pb.h"
#include "fight5v5common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_matchcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_matchcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_matchcommon_2eproto;
namespace common {
class MatchFighter;
struct MatchFighterDefaultTypeInternal;
extern MatchFighterDefaultTypeInternal _MatchFighter_default_instance_;
class MatchFighterExtend;
struct MatchFighterExtendDefaultTypeInternal;
extern MatchFighterExtendDefaultTypeInternal _MatchFighterExtend_default_instance_;
class MatchGroup;
struct MatchGroupDefaultTypeInternal;
extern MatchGroupDefaultTypeInternal _MatchGroup_default_instance_;
class MatchGroupList;
struct MatchGroupListDefaultTypeInternal;
extern MatchGroupListDefaultTypeInternal _MatchGroupList_default_instance_;
class MatchStatus;
struct MatchStatusDefaultTypeInternal;
extern MatchStatusDefaultTypeInternal _MatchStatus_default_instance_;
class MatchTypeData;
struct MatchTypeDataDefaultTypeInternal;
extern MatchTypeDataDefaultTypeInternal _MatchTypeData_default_instance_;
class ModuleMatch;
struct ModuleMatchDefaultTypeInternal;
extern ModuleMatchDefaultTypeInternal _ModuleMatch_default_instance_;
}  // namespace common
PROTOBUF_NAMESPACE_OPEN
template<> ::common::MatchFighter* Arena::CreateMaybeMessage<::common::MatchFighter>(Arena*);
template<> ::common::MatchFighterExtend* Arena::CreateMaybeMessage<::common::MatchFighterExtend>(Arena*);
template<> ::common::MatchGroup* Arena::CreateMaybeMessage<::common::MatchGroup>(Arena*);
template<> ::common::MatchGroupList* Arena::CreateMaybeMessage<::common::MatchGroupList>(Arena*);
template<> ::common::MatchStatus* Arena::CreateMaybeMessage<::common::MatchStatus>(Arena*);
template<> ::common::MatchTypeData* Arena::CreateMaybeMessage<::common::MatchTypeData>(Arena*);
template<> ::common::ModuleMatch* Arena::CreateMaybeMessage<::common::ModuleMatch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace common {

enum enStageId : int {
  enStateId_None = 0,
  enStageId_Confirm = 1,
  enStageId_Loading = 2,
  enStageId_Max = 3,
  enStageId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  enStageId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool enStageId_IsValid(int value);
constexpr enStageId enStageId_MIN = enStateId_None;
constexpr enStageId enStageId_MAX = enStageId_Max;
constexpr int enStageId_ARRAYSIZE = enStageId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* enStageId_descriptor();
template<typename T>
inline const std::string& enStageId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, enStageId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function enStageId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    enStageId_descriptor(), enum_t_value);
}
inline bool enStageId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, enStageId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<enStageId>(
    enStageId_descriptor(), name, value);
}
// ===================================================================

class ModuleMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.ModuleMatch) */ {
 public:
  inline ModuleMatch() : ModuleMatch(nullptr) {}
  ~ModuleMatch() override;
  explicit PROTOBUF_CONSTEXPR ModuleMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModuleMatch(const ModuleMatch& from);
  ModuleMatch(ModuleMatch&& from) noexcept
    : ModuleMatch() {
    *this = ::std::move(from);
  }

  inline ModuleMatch& operator=(const ModuleMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleMatch& operator=(ModuleMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModuleMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModuleMatch* internal_default_instance() {
    return reinterpret_cast<const ModuleMatch*>(
               &_ModuleMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ModuleMatch& a, ModuleMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModuleMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModuleMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModuleMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ModuleMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ModuleMatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.ModuleMatch";
  }
  protected:
  explicit ModuleMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMdataFieldNumber = 1,
    kMstatusFieldNumber = 2,
    kGroupListFieldNumber = 3,
  };
  // .common.MatchTypeData mdata = 1;
  bool has_mdata() const;
  private:
  bool _internal_has_mdata() const;
  public:
  void clear_mdata();
  const ::common::MatchTypeData& mdata() const;
  PROTOBUF_NODISCARD ::common::MatchTypeData* release_mdata();
  ::common::MatchTypeData* mutable_mdata();
  void set_allocated_mdata(::common::MatchTypeData* mdata);
  private:
  const ::common::MatchTypeData& _internal_mdata() const;
  ::common::MatchTypeData* _internal_mutable_mdata();
  public:
  void unsafe_arena_set_allocated_mdata(
      ::common::MatchTypeData* mdata);
  ::common::MatchTypeData* unsafe_arena_release_mdata();

  // .common.MatchStatus mstatus = 2;
  bool has_mstatus() const;
  private:
  bool _internal_has_mstatus() const;
  public:
  void clear_mstatus();
  const ::common::MatchStatus& mstatus() const;
  PROTOBUF_NODISCARD ::common::MatchStatus* release_mstatus();
  ::common::MatchStatus* mutable_mstatus();
  void set_allocated_mstatus(::common::MatchStatus* mstatus);
  private:
  const ::common::MatchStatus& _internal_mstatus() const;
  ::common::MatchStatus* _internal_mutable_mstatus();
  public:
  void unsafe_arena_set_allocated_mstatus(
      ::common::MatchStatus* mstatus);
  ::common::MatchStatus* unsafe_arena_release_mstatus();

  // .common.MatchGroupList groupList = 3;
  bool has_grouplist() const;
  private:
  bool _internal_has_grouplist() const;
  public:
  void clear_grouplist();
  const ::common::MatchGroupList& grouplist() const;
  PROTOBUF_NODISCARD ::common::MatchGroupList* release_grouplist();
  ::common::MatchGroupList* mutable_grouplist();
  void set_allocated_grouplist(::common::MatchGroupList* grouplist);
  private:
  const ::common::MatchGroupList& _internal_grouplist() const;
  ::common::MatchGroupList* _internal_mutable_grouplist();
  public:
  void unsafe_arena_set_allocated_grouplist(
      ::common::MatchGroupList* grouplist);
  ::common::MatchGroupList* unsafe_arena_release_grouplist();

  // @@protoc_insertion_point(class_scope:common.ModuleMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::MatchTypeData* mdata_;
  ::common::MatchStatus* mstatus_;
  ::common::MatchGroupList* grouplist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchTypeData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.MatchTypeData) */ {
 public:
  inline MatchTypeData() : MatchTypeData(nullptr) {}
  ~MatchTypeData() override;
  explicit PROTOBUF_CONSTEXPR MatchTypeData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchTypeData(const MatchTypeData& from);
  MatchTypeData(MatchTypeData&& from) noexcept
    : MatchTypeData() {
    *this = ::std::move(from);
  }

  inline MatchTypeData& operator=(const MatchTypeData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchTypeData& operator=(MatchTypeData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchTypeData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchTypeData* internal_default_instance() {
    return reinterpret_cast<const MatchTypeData*>(
               &_MatchTypeData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(MatchTypeData& a, MatchTypeData& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchTypeData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchTypeData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchTypeData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchTypeData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchTypeData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchTypeData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchTypeData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.MatchTypeData";
  }
  protected:
  explicit MatchTypeData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFight3V3FieldNumber = 1,
    kFight5V5FieldNumber = 2,
  };
  // .common.MatchFight3v3 fight3v3 = 1;
  bool has_fight3v3() const;
  private:
  bool _internal_has_fight3v3() const;
  public:
  void clear_fight3v3();
  const ::common::MatchFight3v3& fight3v3() const;
  PROTOBUF_NODISCARD ::common::MatchFight3v3* release_fight3v3();
  ::common::MatchFight3v3* mutable_fight3v3();
  void set_allocated_fight3v3(::common::MatchFight3v3* fight3v3);
  private:
  const ::common::MatchFight3v3& _internal_fight3v3() const;
  ::common::MatchFight3v3* _internal_mutable_fight3v3();
  public:
  void unsafe_arena_set_allocated_fight3v3(
      ::common::MatchFight3v3* fight3v3);
  ::common::MatchFight3v3* unsafe_arena_release_fight3v3();

  // .common.MatchFight5v5 fight5v5 = 2;
  bool has_fight5v5() const;
  private:
  bool _internal_has_fight5v5() const;
  public:
  void clear_fight5v5();
  const ::common::MatchFight5v5& fight5v5() const;
  PROTOBUF_NODISCARD ::common::MatchFight5v5* release_fight5v5();
  ::common::MatchFight5v5* mutable_fight5v5();
  void set_allocated_fight5v5(::common::MatchFight5v5* fight5v5);
  private:
  const ::common::MatchFight5v5& _internal_fight5v5() const;
  ::common::MatchFight5v5* _internal_mutable_fight5v5();
  public:
  void unsafe_arena_set_allocated_fight5v5(
      ::common::MatchFight5v5* fight5v5);
  ::common::MatchFight5v5* unsafe_arena_release_fight5v5();

  // @@protoc_insertion_point(class_scope:common.MatchTypeData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::MatchFight3v3* fight3v3_;
  ::common::MatchFight5v5* fight5v5_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.MatchStatus) */ {
 public:
  inline MatchStatus() : MatchStatus(nullptr) {}
  ~MatchStatus() override;
  explicit PROTOBUF_CONSTEXPR MatchStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchStatus(const MatchStatus& from);
  MatchStatus(MatchStatus&& from) noexcept
    : MatchStatus() {
    *this = ::std::move(from);
  }

  inline MatchStatus& operator=(const MatchStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchStatus& operator=(MatchStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchStatus* internal_default_instance() {
    return reinterpret_cast<const MatchStatus*>(
               &_MatchStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MatchStatus& a, MatchStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.MatchStatus";
  }
  protected:
  explicit MatchStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMtypeFieldNumber = 1,
    kMtimeFieldNumber = 2,
  };
  // uint32 mtype = 1;
  void clear_mtype();
  uint32_t mtype() const;
  void set_mtype(uint32_t value);
  private:
  uint32_t _internal_mtype() const;
  void _internal_set_mtype(uint32_t value);
  public:

  // uint32 mtime = 2;
  void clear_mtime();
  uint32_t mtime() const;
  void set_mtime(uint32_t value);
  private:
  uint32_t _internal_mtime() const;
  void _internal_set_mtime(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.MatchStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t mtype_;
  uint32_t mtime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchGroupList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.MatchGroupList) */ {
 public:
  inline MatchGroupList() : MatchGroupList(nullptr) {}
  ~MatchGroupList() override;
  explicit PROTOBUF_CONSTEXPR MatchGroupList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchGroupList(const MatchGroupList& from);
  MatchGroupList(MatchGroupList&& from) noexcept
    : MatchGroupList() {
    *this = ::std::move(from);
  }

  inline MatchGroupList& operator=(const MatchGroupList& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchGroupList& operator=(MatchGroupList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchGroupList& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchGroupList* internal_default_instance() {
    return reinterpret_cast<const MatchGroupList*>(
               &_MatchGroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MatchGroupList& a, MatchGroupList& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchGroupList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchGroupList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchGroupList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchGroupList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchGroupList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchGroupList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchGroupList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.MatchGroupList";
  }
  protected:
  explicit MatchGroupList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedFieldNumber = 1,
    kBlueFieldNumber = 2,
    kExpireFieldNumber = 3,
    kStageIdFieldNumber = 4,
  };
  // .common.MatchGroup red = 1;
  bool has_red() const;
  private:
  bool _internal_has_red() const;
  public:
  void clear_red();
  const ::common::MatchGroup& red() const;
  PROTOBUF_NODISCARD ::common::MatchGroup* release_red();
  ::common::MatchGroup* mutable_red();
  void set_allocated_red(::common::MatchGroup* red);
  private:
  const ::common::MatchGroup& _internal_red() const;
  ::common::MatchGroup* _internal_mutable_red();
  public:
  void unsafe_arena_set_allocated_red(
      ::common::MatchGroup* red);
  ::common::MatchGroup* unsafe_arena_release_red();

  // .common.MatchGroup blue = 2;
  bool has_blue() const;
  private:
  bool _internal_has_blue() const;
  public:
  void clear_blue();
  const ::common::MatchGroup& blue() const;
  PROTOBUF_NODISCARD ::common::MatchGroup* release_blue();
  ::common::MatchGroup* mutable_blue();
  void set_allocated_blue(::common::MatchGroup* blue);
  private:
  const ::common::MatchGroup& _internal_blue() const;
  ::common::MatchGroup* _internal_mutable_blue();
  public:
  void unsafe_arena_set_allocated_blue(
      ::common::MatchGroup* blue);
  ::common::MatchGroup* unsafe_arena_release_blue();

  // uint32 expire = 3;
  void clear_expire();
  uint32_t expire() const;
  void set_expire(uint32_t value);
  private:
  uint32_t _internal_expire() const;
  void _internal_set_expire(uint32_t value);
  public:

  // uint32 stageId = 4;
  void clear_stageid();
  uint32_t stageid() const;
  void set_stageid(uint32_t value);
  private:
  uint32_t _internal_stageid() const;
  void _internal_set_stageid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.MatchGroupList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::MatchGroup* red_;
  ::common::MatchGroup* blue_;
  uint32_t expire_;
  uint32_t stageid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.MatchGroup) */ {
 public:
  inline MatchGroup() : MatchGroup(nullptr) {}
  ~MatchGroup() override;
  explicit PROTOBUF_CONSTEXPR MatchGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchGroup(const MatchGroup& from);
  MatchGroup(MatchGroup&& from) noexcept
    : MatchGroup() {
    *this = ::std::move(from);
  }

  inline MatchGroup& operator=(const MatchGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchGroup& operator=(MatchGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchGroup* internal_default_instance() {
    return reinterpret_cast<const MatchGroup*>(
               &_MatchGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MatchGroup& a, MatchGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.MatchGroup";
  }
  protected:
  explicit MatchGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFightersFieldNumber = 1,
  };
  // repeated .common.MatchFighter fighters = 1;
  int fighters_size() const;
  private:
  int _internal_fighters_size() const;
  public:
  void clear_fighters();
  ::common::MatchFighter* mutable_fighters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::MatchFighter >*
      mutable_fighters();
  private:
  const ::common::MatchFighter& _internal_fighters(int index) const;
  ::common::MatchFighter* _internal_add_fighters();
  public:
  const ::common::MatchFighter& fighters(int index) const;
  ::common::MatchFighter* add_fighters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::MatchFighter >&
      fighters() const;

  // @@protoc_insertion_point(class_scope:common.MatchGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::MatchFighter > fighters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchFighter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.MatchFighter) */ {
 public:
  inline MatchFighter() : MatchFighter(nullptr) {}
  ~MatchFighter() override;
  explicit PROTOBUF_CONSTEXPR MatchFighter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchFighter(const MatchFighter& from);
  MatchFighter(MatchFighter&& from) noexcept
    : MatchFighter() {
    *this = ::std::move(from);
  }

  inline MatchFighter& operator=(const MatchFighter& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchFighter& operator=(MatchFighter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchFighter& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchFighter* internal_default_instance() {
    return reinterpret_cast<const MatchFighter*>(
               &_MatchFighter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MatchFighter& a, MatchFighter& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchFighter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchFighter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchFighter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchFighter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchFighter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchFighter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchFighter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.MatchFighter";
  }
  protected:
  explicit MatchFighter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBriefFieldNumber = 1,
    kExtdFieldNumber = 2,
    kIsokFieldNumber = 3,
  };
  // .common.RoleBrief brief = 1;
  bool has_brief() const;
  private:
  bool _internal_has_brief() const;
  public:
  void clear_brief();
  const ::common::RoleBrief& brief() const;
  PROTOBUF_NODISCARD ::common::RoleBrief* release_brief();
  ::common::RoleBrief* mutable_brief();
  void set_allocated_brief(::common::RoleBrief* brief);
  private:
  const ::common::RoleBrief& _internal_brief() const;
  ::common::RoleBrief* _internal_mutable_brief();
  public:
  void unsafe_arena_set_allocated_brief(
      ::common::RoleBrief* brief);
  ::common::RoleBrief* unsafe_arena_release_brief();

  // .common.MatchFighterExtend extd = 2;
  bool has_extd() const;
  private:
  bool _internal_has_extd() const;
  public:
  void clear_extd();
  const ::common::MatchFighterExtend& extd() const;
  PROTOBUF_NODISCARD ::common::MatchFighterExtend* release_extd();
  ::common::MatchFighterExtend* mutable_extd();
  void set_allocated_extd(::common::MatchFighterExtend* extd);
  private:
  const ::common::MatchFighterExtend& _internal_extd() const;
  ::common::MatchFighterExtend* _internal_mutable_extd();
  public:
  void unsafe_arena_set_allocated_extd(
      ::common::MatchFighterExtend* extd);
  ::common::MatchFighterExtend* unsafe_arena_release_extd();

  // bool isok = 3;
  void clear_isok();
  bool isok() const;
  void set_isok(bool value);
  private:
  bool _internal_isok() const;
  void _internal_set_isok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.MatchFighter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::RoleBrief* brief_;
  ::common::MatchFighterExtend* extd_;
  bool isok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchFighterExtend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.MatchFighterExtend) */ {
 public:
  inline MatchFighterExtend() : MatchFighterExtend(nullptr) {}
  ~MatchFighterExtend() override;
  explicit PROTOBUF_CONSTEXPR MatchFighterExtend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchFighterExtend(const MatchFighterExtend& from);
  MatchFighterExtend(MatchFighterExtend&& from) noexcept
    : MatchFighterExtend() {
    *this = ::std::move(from);
  }

  inline MatchFighterExtend& operator=(const MatchFighterExtend& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchFighterExtend& operator=(MatchFighterExtend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchFighterExtend& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchFighterExtend* internal_default_instance() {
    return reinterpret_cast<const MatchFighterExtend*>(
               &_MatchFighterExtend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MatchFighterExtend& a, MatchFighterExtend& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchFighterExtend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchFighterExtend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchFighterExtend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchFighterExtend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchFighterExtend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchFighterExtend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchFighterExtend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.MatchFighterExtend";
  }
  protected:
  explicit MatchFighterExtend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFight3V3FieldNumber = 1,
    kFight5V5FieldNumber = 2,
  };
  // .common.ExtendFight3v3 fight3v3 = 1;
  bool has_fight3v3() const;
  private:
  bool _internal_has_fight3v3() const;
  public:
  void clear_fight3v3();
  const ::common::ExtendFight3v3& fight3v3() const;
  PROTOBUF_NODISCARD ::common::ExtendFight3v3* release_fight3v3();
  ::common::ExtendFight3v3* mutable_fight3v3();
  void set_allocated_fight3v3(::common::ExtendFight3v3* fight3v3);
  private:
  const ::common::ExtendFight3v3& _internal_fight3v3() const;
  ::common::ExtendFight3v3* _internal_mutable_fight3v3();
  public:
  void unsafe_arena_set_allocated_fight3v3(
      ::common::ExtendFight3v3* fight3v3);
  ::common::ExtendFight3v3* unsafe_arena_release_fight3v3();

  // .common.ExtendFight5v5 fight5v5 = 2;
  bool has_fight5v5() const;
  private:
  bool _internal_has_fight5v5() const;
  public:
  void clear_fight5v5();
  const ::common::ExtendFight5v5& fight5v5() const;
  PROTOBUF_NODISCARD ::common::ExtendFight5v5* release_fight5v5();
  ::common::ExtendFight5v5* mutable_fight5v5();
  void set_allocated_fight5v5(::common::ExtendFight5v5* fight5v5);
  private:
  const ::common::ExtendFight5v5& _internal_fight5v5() const;
  ::common::ExtendFight5v5* _internal_mutable_fight5v5();
  public:
  void unsafe_arena_set_allocated_fight5v5(
      ::common::ExtendFight5v5* fight5v5);
  ::common::ExtendFight5v5* unsafe_arena_release_fight5v5();

  // @@protoc_insertion_point(class_scope:common.MatchFighterExtend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::ExtendFight3v3* fight3v3_;
  ::common::ExtendFight5v5* fight5v5_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_matchcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModuleMatch

// .common.MatchTypeData mdata = 1;
inline bool ModuleMatch::_internal_has_mdata() const {
  return this != internal_default_instance() && mdata_ != nullptr;
}
inline bool ModuleMatch::has_mdata() const {
  return _internal_has_mdata();
}
inline void ModuleMatch::clear_mdata() {
  if (GetArenaForAllocation() == nullptr && mdata_ != nullptr) {
    delete mdata_;
  }
  mdata_ = nullptr;
}
inline const ::common::MatchTypeData& ModuleMatch::_internal_mdata() const {
  const ::common::MatchTypeData* p = mdata_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchTypeData&>(
      ::common::_MatchTypeData_default_instance_);
}
inline const ::common::MatchTypeData& ModuleMatch::mdata() const {
  // @@protoc_insertion_point(field_get:common.ModuleMatch.mdata)
  return _internal_mdata();
}
inline void ModuleMatch::unsafe_arena_set_allocated_mdata(
    ::common::MatchTypeData* mdata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mdata_);
  }
  mdata_ = mdata;
  if (mdata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.ModuleMatch.mdata)
}
inline ::common::MatchTypeData* ModuleMatch::release_mdata() {
  
  ::common::MatchTypeData* temp = mdata_;
  mdata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchTypeData* ModuleMatch::unsafe_arena_release_mdata() {
  // @@protoc_insertion_point(field_release:common.ModuleMatch.mdata)
  
  ::common::MatchTypeData* temp = mdata_;
  mdata_ = nullptr;
  return temp;
}
inline ::common::MatchTypeData* ModuleMatch::_internal_mutable_mdata() {
  
  if (mdata_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchTypeData>(GetArenaForAllocation());
    mdata_ = p;
  }
  return mdata_;
}
inline ::common::MatchTypeData* ModuleMatch::mutable_mdata() {
  ::common::MatchTypeData* _msg = _internal_mutable_mdata();
  // @@protoc_insertion_point(field_mutable:common.ModuleMatch.mdata)
  return _msg;
}
inline void ModuleMatch::set_allocated_mdata(::common::MatchTypeData* mdata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mdata_;
  }
  if (mdata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mdata);
    if (message_arena != submessage_arena) {
      mdata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mdata, submessage_arena);
    }
    
  } else {
    
  }
  mdata_ = mdata;
  // @@protoc_insertion_point(field_set_allocated:common.ModuleMatch.mdata)
}

// .common.MatchStatus mstatus = 2;
inline bool ModuleMatch::_internal_has_mstatus() const {
  return this != internal_default_instance() && mstatus_ != nullptr;
}
inline bool ModuleMatch::has_mstatus() const {
  return _internal_has_mstatus();
}
inline void ModuleMatch::clear_mstatus() {
  if (GetArenaForAllocation() == nullptr && mstatus_ != nullptr) {
    delete mstatus_;
  }
  mstatus_ = nullptr;
}
inline const ::common::MatchStatus& ModuleMatch::_internal_mstatus() const {
  const ::common::MatchStatus* p = mstatus_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchStatus&>(
      ::common::_MatchStatus_default_instance_);
}
inline const ::common::MatchStatus& ModuleMatch::mstatus() const {
  // @@protoc_insertion_point(field_get:common.ModuleMatch.mstatus)
  return _internal_mstatus();
}
inline void ModuleMatch::unsafe_arena_set_allocated_mstatus(
    ::common::MatchStatus* mstatus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mstatus_);
  }
  mstatus_ = mstatus;
  if (mstatus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.ModuleMatch.mstatus)
}
inline ::common::MatchStatus* ModuleMatch::release_mstatus() {
  
  ::common::MatchStatus* temp = mstatus_;
  mstatus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchStatus* ModuleMatch::unsafe_arena_release_mstatus() {
  // @@protoc_insertion_point(field_release:common.ModuleMatch.mstatus)
  
  ::common::MatchStatus* temp = mstatus_;
  mstatus_ = nullptr;
  return temp;
}
inline ::common::MatchStatus* ModuleMatch::_internal_mutable_mstatus() {
  
  if (mstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchStatus>(GetArenaForAllocation());
    mstatus_ = p;
  }
  return mstatus_;
}
inline ::common::MatchStatus* ModuleMatch::mutable_mstatus() {
  ::common::MatchStatus* _msg = _internal_mutable_mstatus();
  // @@protoc_insertion_point(field_mutable:common.ModuleMatch.mstatus)
  return _msg;
}
inline void ModuleMatch::set_allocated_mstatus(::common::MatchStatus* mstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete mstatus_;
  }
  if (mstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mstatus);
    if (message_arena != submessage_arena) {
      mstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mstatus, submessage_arena);
    }
    
  } else {
    
  }
  mstatus_ = mstatus;
  // @@protoc_insertion_point(field_set_allocated:common.ModuleMatch.mstatus)
}

// .common.MatchGroupList groupList = 3;
inline bool ModuleMatch::_internal_has_grouplist() const {
  return this != internal_default_instance() && grouplist_ != nullptr;
}
inline bool ModuleMatch::has_grouplist() const {
  return _internal_has_grouplist();
}
inline void ModuleMatch::clear_grouplist() {
  if (GetArenaForAllocation() == nullptr && grouplist_ != nullptr) {
    delete grouplist_;
  }
  grouplist_ = nullptr;
}
inline const ::common::MatchGroupList& ModuleMatch::_internal_grouplist() const {
  const ::common::MatchGroupList* p = grouplist_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchGroupList&>(
      ::common::_MatchGroupList_default_instance_);
}
inline const ::common::MatchGroupList& ModuleMatch::grouplist() const {
  // @@protoc_insertion_point(field_get:common.ModuleMatch.groupList)
  return _internal_grouplist();
}
inline void ModuleMatch::unsafe_arena_set_allocated_grouplist(
    ::common::MatchGroupList* grouplist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grouplist_);
  }
  grouplist_ = grouplist;
  if (grouplist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.ModuleMatch.groupList)
}
inline ::common::MatchGroupList* ModuleMatch::release_grouplist() {
  
  ::common::MatchGroupList* temp = grouplist_;
  grouplist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchGroupList* ModuleMatch::unsafe_arena_release_grouplist() {
  // @@protoc_insertion_point(field_release:common.ModuleMatch.groupList)
  
  ::common::MatchGroupList* temp = grouplist_;
  grouplist_ = nullptr;
  return temp;
}
inline ::common::MatchGroupList* ModuleMatch::_internal_mutable_grouplist() {
  
  if (grouplist_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchGroupList>(GetArenaForAllocation());
    grouplist_ = p;
  }
  return grouplist_;
}
inline ::common::MatchGroupList* ModuleMatch::mutable_grouplist() {
  ::common::MatchGroupList* _msg = _internal_mutable_grouplist();
  // @@protoc_insertion_point(field_mutable:common.ModuleMatch.groupList)
  return _msg;
}
inline void ModuleMatch::set_allocated_grouplist(::common::MatchGroupList* grouplist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete grouplist_;
  }
  if (grouplist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(grouplist);
    if (message_arena != submessage_arena) {
      grouplist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grouplist, submessage_arena);
    }
    
  } else {
    
  }
  grouplist_ = grouplist;
  // @@protoc_insertion_point(field_set_allocated:common.ModuleMatch.groupList)
}

// -------------------------------------------------------------------

// MatchTypeData

// .common.MatchFight3v3 fight3v3 = 1;
inline bool MatchTypeData::_internal_has_fight3v3() const {
  return this != internal_default_instance() && fight3v3_ != nullptr;
}
inline bool MatchTypeData::has_fight3v3() const {
  return _internal_has_fight3v3();
}
inline const ::common::MatchFight3v3& MatchTypeData::_internal_fight3v3() const {
  const ::common::MatchFight3v3* p = fight3v3_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchFight3v3&>(
      ::common::_MatchFight3v3_default_instance_);
}
inline const ::common::MatchFight3v3& MatchTypeData::fight3v3() const {
  // @@protoc_insertion_point(field_get:common.MatchTypeData.fight3v3)
  return _internal_fight3v3();
}
inline void MatchTypeData::unsafe_arena_set_allocated_fight3v3(
    ::common::MatchFight3v3* fight3v3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight3v3_);
  }
  fight3v3_ = fight3v3;
  if (fight3v3) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchTypeData.fight3v3)
}
inline ::common::MatchFight3v3* MatchTypeData::release_fight3v3() {
  
  ::common::MatchFight3v3* temp = fight3v3_;
  fight3v3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchFight3v3* MatchTypeData::unsafe_arena_release_fight3v3() {
  // @@protoc_insertion_point(field_release:common.MatchTypeData.fight3v3)
  
  ::common::MatchFight3v3* temp = fight3v3_;
  fight3v3_ = nullptr;
  return temp;
}
inline ::common::MatchFight3v3* MatchTypeData::_internal_mutable_fight3v3() {
  
  if (fight3v3_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchFight3v3>(GetArenaForAllocation());
    fight3v3_ = p;
  }
  return fight3v3_;
}
inline ::common::MatchFight3v3* MatchTypeData::mutable_fight3v3() {
  ::common::MatchFight3v3* _msg = _internal_mutable_fight3v3();
  // @@protoc_insertion_point(field_mutable:common.MatchTypeData.fight3v3)
  return _msg;
}
inline void MatchTypeData::set_allocated_fight3v3(::common::MatchFight3v3* fight3v3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight3v3_);
  }
  if (fight3v3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight3v3));
    if (message_arena != submessage_arena) {
      fight3v3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fight3v3, submessage_arena);
    }
    
  } else {
    
  }
  fight3v3_ = fight3v3;
  // @@protoc_insertion_point(field_set_allocated:common.MatchTypeData.fight3v3)
}

// .common.MatchFight5v5 fight5v5 = 2;
inline bool MatchTypeData::_internal_has_fight5v5() const {
  return this != internal_default_instance() && fight5v5_ != nullptr;
}
inline bool MatchTypeData::has_fight5v5() const {
  return _internal_has_fight5v5();
}
inline const ::common::MatchFight5v5& MatchTypeData::_internal_fight5v5() const {
  const ::common::MatchFight5v5* p = fight5v5_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchFight5v5&>(
      ::common::_MatchFight5v5_default_instance_);
}
inline const ::common::MatchFight5v5& MatchTypeData::fight5v5() const {
  // @@protoc_insertion_point(field_get:common.MatchTypeData.fight5v5)
  return _internal_fight5v5();
}
inline void MatchTypeData::unsafe_arena_set_allocated_fight5v5(
    ::common::MatchFight5v5* fight5v5) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight5v5_);
  }
  fight5v5_ = fight5v5;
  if (fight5v5) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchTypeData.fight5v5)
}
inline ::common::MatchFight5v5* MatchTypeData::release_fight5v5() {
  
  ::common::MatchFight5v5* temp = fight5v5_;
  fight5v5_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchFight5v5* MatchTypeData::unsafe_arena_release_fight5v5() {
  // @@protoc_insertion_point(field_release:common.MatchTypeData.fight5v5)
  
  ::common::MatchFight5v5* temp = fight5v5_;
  fight5v5_ = nullptr;
  return temp;
}
inline ::common::MatchFight5v5* MatchTypeData::_internal_mutable_fight5v5() {
  
  if (fight5v5_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchFight5v5>(GetArenaForAllocation());
    fight5v5_ = p;
  }
  return fight5v5_;
}
inline ::common::MatchFight5v5* MatchTypeData::mutable_fight5v5() {
  ::common::MatchFight5v5* _msg = _internal_mutable_fight5v5();
  // @@protoc_insertion_point(field_mutable:common.MatchTypeData.fight5v5)
  return _msg;
}
inline void MatchTypeData::set_allocated_fight5v5(::common::MatchFight5v5* fight5v5) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight5v5_);
  }
  if (fight5v5) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight5v5));
    if (message_arena != submessage_arena) {
      fight5v5 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fight5v5, submessage_arena);
    }
    
  } else {
    
  }
  fight5v5_ = fight5v5;
  // @@protoc_insertion_point(field_set_allocated:common.MatchTypeData.fight5v5)
}

// -------------------------------------------------------------------

// MatchStatus

// uint32 mtype = 1;
inline void MatchStatus::clear_mtype() {
  mtype_ = 0u;
}
inline uint32_t MatchStatus::_internal_mtype() const {
  return mtype_;
}
inline uint32_t MatchStatus::mtype() const {
  // @@protoc_insertion_point(field_get:common.MatchStatus.mtype)
  return _internal_mtype();
}
inline void MatchStatus::_internal_set_mtype(uint32_t value) {
  
  mtype_ = value;
}
inline void MatchStatus::set_mtype(uint32_t value) {
  _internal_set_mtype(value);
  // @@protoc_insertion_point(field_set:common.MatchStatus.mtype)
}

// uint32 mtime = 2;
inline void MatchStatus::clear_mtime() {
  mtime_ = 0u;
}
inline uint32_t MatchStatus::_internal_mtime() const {
  return mtime_;
}
inline uint32_t MatchStatus::mtime() const {
  // @@protoc_insertion_point(field_get:common.MatchStatus.mtime)
  return _internal_mtime();
}
inline void MatchStatus::_internal_set_mtime(uint32_t value) {
  
  mtime_ = value;
}
inline void MatchStatus::set_mtime(uint32_t value) {
  _internal_set_mtime(value);
  // @@protoc_insertion_point(field_set:common.MatchStatus.mtime)
}

// -------------------------------------------------------------------

// MatchGroupList

// .common.MatchGroup red = 1;
inline bool MatchGroupList::_internal_has_red() const {
  return this != internal_default_instance() && red_ != nullptr;
}
inline bool MatchGroupList::has_red() const {
  return _internal_has_red();
}
inline void MatchGroupList::clear_red() {
  if (GetArenaForAllocation() == nullptr && red_ != nullptr) {
    delete red_;
  }
  red_ = nullptr;
}
inline const ::common::MatchGroup& MatchGroupList::_internal_red() const {
  const ::common::MatchGroup* p = red_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchGroup&>(
      ::common::_MatchGroup_default_instance_);
}
inline const ::common::MatchGroup& MatchGroupList::red() const {
  // @@protoc_insertion_point(field_get:common.MatchGroupList.red)
  return _internal_red();
}
inline void MatchGroupList::unsafe_arena_set_allocated_red(
    ::common::MatchGroup* red) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(red_);
  }
  red_ = red;
  if (red) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchGroupList.red)
}
inline ::common::MatchGroup* MatchGroupList::release_red() {
  
  ::common::MatchGroup* temp = red_;
  red_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchGroup* MatchGroupList::unsafe_arena_release_red() {
  // @@protoc_insertion_point(field_release:common.MatchGroupList.red)
  
  ::common::MatchGroup* temp = red_;
  red_ = nullptr;
  return temp;
}
inline ::common::MatchGroup* MatchGroupList::_internal_mutable_red() {
  
  if (red_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchGroup>(GetArenaForAllocation());
    red_ = p;
  }
  return red_;
}
inline ::common::MatchGroup* MatchGroupList::mutable_red() {
  ::common::MatchGroup* _msg = _internal_mutable_red();
  // @@protoc_insertion_point(field_mutable:common.MatchGroupList.red)
  return _msg;
}
inline void MatchGroupList::set_allocated_red(::common::MatchGroup* red) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete red_;
  }
  if (red) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(red);
    if (message_arena != submessage_arena) {
      red = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, red, submessage_arena);
    }
    
  } else {
    
  }
  red_ = red;
  // @@protoc_insertion_point(field_set_allocated:common.MatchGroupList.red)
}

// .common.MatchGroup blue = 2;
inline bool MatchGroupList::_internal_has_blue() const {
  return this != internal_default_instance() && blue_ != nullptr;
}
inline bool MatchGroupList::has_blue() const {
  return _internal_has_blue();
}
inline void MatchGroupList::clear_blue() {
  if (GetArenaForAllocation() == nullptr && blue_ != nullptr) {
    delete blue_;
  }
  blue_ = nullptr;
}
inline const ::common::MatchGroup& MatchGroupList::_internal_blue() const {
  const ::common::MatchGroup* p = blue_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchGroup&>(
      ::common::_MatchGroup_default_instance_);
}
inline const ::common::MatchGroup& MatchGroupList::blue() const {
  // @@protoc_insertion_point(field_get:common.MatchGroupList.blue)
  return _internal_blue();
}
inline void MatchGroupList::unsafe_arena_set_allocated_blue(
    ::common::MatchGroup* blue) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blue_);
  }
  blue_ = blue;
  if (blue) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchGroupList.blue)
}
inline ::common::MatchGroup* MatchGroupList::release_blue() {
  
  ::common::MatchGroup* temp = blue_;
  blue_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchGroup* MatchGroupList::unsafe_arena_release_blue() {
  // @@protoc_insertion_point(field_release:common.MatchGroupList.blue)
  
  ::common::MatchGroup* temp = blue_;
  blue_ = nullptr;
  return temp;
}
inline ::common::MatchGroup* MatchGroupList::_internal_mutable_blue() {
  
  if (blue_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchGroup>(GetArenaForAllocation());
    blue_ = p;
  }
  return blue_;
}
inline ::common::MatchGroup* MatchGroupList::mutable_blue() {
  ::common::MatchGroup* _msg = _internal_mutable_blue();
  // @@protoc_insertion_point(field_mutable:common.MatchGroupList.blue)
  return _msg;
}
inline void MatchGroupList::set_allocated_blue(::common::MatchGroup* blue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete blue_;
  }
  if (blue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(blue);
    if (message_arena != submessage_arena) {
      blue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blue, submessage_arena);
    }
    
  } else {
    
  }
  blue_ = blue;
  // @@protoc_insertion_point(field_set_allocated:common.MatchGroupList.blue)
}

// uint32 expire = 3;
inline void MatchGroupList::clear_expire() {
  expire_ = 0u;
}
inline uint32_t MatchGroupList::_internal_expire() const {
  return expire_;
}
inline uint32_t MatchGroupList::expire() const {
  // @@protoc_insertion_point(field_get:common.MatchGroupList.expire)
  return _internal_expire();
}
inline void MatchGroupList::_internal_set_expire(uint32_t value) {
  
  expire_ = value;
}
inline void MatchGroupList::set_expire(uint32_t value) {
  _internal_set_expire(value);
  // @@protoc_insertion_point(field_set:common.MatchGroupList.expire)
}

// uint32 stageId = 4;
inline void MatchGroupList::clear_stageid() {
  stageid_ = 0u;
}
inline uint32_t MatchGroupList::_internal_stageid() const {
  return stageid_;
}
inline uint32_t MatchGroupList::stageid() const {
  // @@protoc_insertion_point(field_get:common.MatchGroupList.stageId)
  return _internal_stageid();
}
inline void MatchGroupList::_internal_set_stageid(uint32_t value) {
  
  stageid_ = value;
}
inline void MatchGroupList::set_stageid(uint32_t value) {
  _internal_set_stageid(value);
  // @@protoc_insertion_point(field_set:common.MatchGroupList.stageId)
}

// -------------------------------------------------------------------

// MatchGroup

// repeated .common.MatchFighter fighters = 1;
inline int MatchGroup::_internal_fighters_size() const {
  return fighters_.size();
}
inline int MatchGroup::fighters_size() const {
  return _internal_fighters_size();
}
inline void MatchGroup::clear_fighters() {
  fighters_.Clear();
}
inline ::common::MatchFighter* MatchGroup::mutable_fighters(int index) {
  // @@protoc_insertion_point(field_mutable:common.MatchGroup.fighters)
  return fighters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::MatchFighter >*
MatchGroup::mutable_fighters() {
  // @@protoc_insertion_point(field_mutable_list:common.MatchGroup.fighters)
  return &fighters_;
}
inline const ::common::MatchFighter& MatchGroup::_internal_fighters(int index) const {
  return fighters_.Get(index);
}
inline const ::common::MatchFighter& MatchGroup::fighters(int index) const {
  // @@protoc_insertion_point(field_get:common.MatchGroup.fighters)
  return _internal_fighters(index);
}
inline ::common::MatchFighter* MatchGroup::_internal_add_fighters() {
  return fighters_.Add();
}
inline ::common::MatchFighter* MatchGroup::add_fighters() {
  ::common::MatchFighter* _add = _internal_add_fighters();
  // @@protoc_insertion_point(field_add:common.MatchGroup.fighters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::MatchFighter >&
MatchGroup::fighters() const {
  // @@protoc_insertion_point(field_list:common.MatchGroup.fighters)
  return fighters_;
}

// -------------------------------------------------------------------

// MatchFighter

// .common.RoleBrief brief = 1;
inline bool MatchFighter::_internal_has_brief() const {
  return this != internal_default_instance() && brief_ != nullptr;
}
inline bool MatchFighter::has_brief() const {
  return _internal_has_brief();
}
inline const ::common::RoleBrief& MatchFighter::_internal_brief() const {
  const ::common::RoleBrief* p = brief_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::RoleBrief&>(
      ::common::_RoleBrief_default_instance_);
}
inline const ::common::RoleBrief& MatchFighter::brief() const {
  // @@protoc_insertion_point(field_get:common.MatchFighter.brief)
  return _internal_brief();
}
inline void MatchFighter::unsafe_arena_set_allocated_brief(
    ::common::RoleBrief* brief) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(brief_);
  }
  brief_ = brief;
  if (brief) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchFighter.brief)
}
inline ::common::RoleBrief* MatchFighter::release_brief() {
  
  ::common::RoleBrief* temp = brief_;
  brief_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::RoleBrief* MatchFighter::unsafe_arena_release_brief() {
  // @@protoc_insertion_point(field_release:common.MatchFighter.brief)
  
  ::common::RoleBrief* temp = brief_;
  brief_ = nullptr;
  return temp;
}
inline ::common::RoleBrief* MatchFighter::_internal_mutable_brief() {
  
  if (brief_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::RoleBrief>(GetArenaForAllocation());
    brief_ = p;
  }
  return brief_;
}
inline ::common::RoleBrief* MatchFighter::mutable_brief() {
  ::common::RoleBrief* _msg = _internal_mutable_brief();
  // @@protoc_insertion_point(field_mutable:common.MatchFighter.brief)
  return _msg;
}
inline void MatchFighter::set_allocated_brief(::common::RoleBrief* brief) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(brief_);
  }
  if (brief) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(brief));
    if (message_arena != submessage_arena) {
      brief = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brief, submessage_arena);
    }
    
  } else {
    
  }
  brief_ = brief;
  // @@protoc_insertion_point(field_set_allocated:common.MatchFighter.brief)
}

// .common.MatchFighterExtend extd = 2;
inline bool MatchFighter::_internal_has_extd() const {
  return this != internal_default_instance() && extd_ != nullptr;
}
inline bool MatchFighter::has_extd() const {
  return _internal_has_extd();
}
inline void MatchFighter::clear_extd() {
  if (GetArenaForAllocation() == nullptr && extd_ != nullptr) {
    delete extd_;
  }
  extd_ = nullptr;
}
inline const ::common::MatchFighterExtend& MatchFighter::_internal_extd() const {
  const ::common::MatchFighterExtend* p = extd_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MatchFighterExtend&>(
      ::common::_MatchFighterExtend_default_instance_);
}
inline const ::common::MatchFighterExtend& MatchFighter::extd() const {
  // @@protoc_insertion_point(field_get:common.MatchFighter.extd)
  return _internal_extd();
}
inline void MatchFighter::unsafe_arena_set_allocated_extd(
    ::common::MatchFighterExtend* extd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extd_);
  }
  extd_ = extd;
  if (extd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchFighter.extd)
}
inline ::common::MatchFighterExtend* MatchFighter::release_extd() {
  
  ::common::MatchFighterExtend* temp = extd_;
  extd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MatchFighterExtend* MatchFighter::unsafe_arena_release_extd() {
  // @@protoc_insertion_point(field_release:common.MatchFighter.extd)
  
  ::common::MatchFighterExtend* temp = extd_;
  extd_ = nullptr;
  return temp;
}
inline ::common::MatchFighterExtend* MatchFighter::_internal_mutable_extd() {
  
  if (extd_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MatchFighterExtend>(GetArenaForAllocation());
    extd_ = p;
  }
  return extd_;
}
inline ::common::MatchFighterExtend* MatchFighter::mutable_extd() {
  ::common::MatchFighterExtend* _msg = _internal_mutable_extd();
  // @@protoc_insertion_point(field_mutable:common.MatchFighter.extd)
  return _msg;
}
inline void MatchFighter::set_allocated_extd(::common::MatchFighterExtend* extd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete extd_;
  }
  if (extd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extd);
    if (message_arena != submessage_arena) {
      extd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extd, submessage_arena);
    }
    
  } else {
    
  }
  extd_ = extd;
  // @@protoc_insertion_point(field_set_allocated:common.MatchFighter.extd)
}

// bool isok = 3;
inline void MatchFighter::clear_isok() {
  isok_ = false;
}
inline bool MatchFighter::_internal_isok() const {
  return isok_;
}
inline bool MatchFighter::isok() const {
  // @@protoc_insertion_point(field_get:common.MatchFighter.isok)
  return _internal_isok();
}
inline void MatchFighter::_internal_set_isok(bool value) {
  
  isok_ = value;
}
inline void MatchFighter::set_isok(bool value) {
  _internal_set_isok(value);
  // @@protoc_insertion_point(field_set:common.MatchFighter.isok)
}

// -------------------------------------------------------------------

// MatchFighterExtend

// .common.ExtendFight3v3 fight3v3 = 1;
inline bool MatchFighterExtend::_internal_has_fight3v3() const {
  return this != internal_default_instance() && fight3v3_ != nullptr;
}
inline bool MatchFighterExtend::has_fight3v3() const {
  return _internal_has_fight3v3();
}
inline const ::common::ExtendFight3v3& MatchFighterExtend::_internal_fight3v3() const {
  const ::common::ExtendFight3v3* p = fight3v3_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::ExtendFight3v3&>(
      ::common::_ExtendFight3v3_default_instance_);
}
inline const ::common::ExtendFight3v3& MatchFighterExtend::fight3v3() const {
  // @@protoc_insertion_point(field_get:common.MatchFighterExtend.fight3v3)
  return _internal_fight3v3();
}
inline void MatchFighterExtend::unsafe_arena_set_allocated_fight3v3(
    ::common::ExtendFight3v3* fight3v3) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight3v3_);
  }
  fight3v3_ = fight3v3;
  if (fight3v3) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchFighterExtend.fight3v3)
}
inline ::common::ExtendFight3v3* MatchFighterExtend::release_fight3v3() {
  
  ::common::ExtendFight3v3* temp = fight3v3_;
  fight3v3_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::ExtendFight3v3* MatchFighterExtend::unsafe_arena_release_fight3v3() {
  // @@protoc_insertion_point(field_release:common.MatchFighterExtend.fight3v3)
  
  ::common::ExtendFight3v3* temp = fight3v3_;
  fight3v3_ = nullptr;
  return temp;
}
inline ::common::ExtendFight3v3* MatchFighterExtend::_internal_mutable_fight3v3() {
  
  if (fight3v3_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ExtendFight3v3>(GetArenaForAllocation());
    fight3v3_ = p;
  }
  return fight3v3_;
}
inline ::common::ExtendFight3v3* MatchFighterExtend::mutable_fight3v3() {
  ::common::ExtendFight3v3* _msg = _internal_mutable_fight3v3();
  // @@protoc_insertion_point(field_mutable:common.MatchFighterExtend.fight3v3)
  return _msg;
}
inline void MatchFighterExtend::set_allocated_fight3v3(::common::ExtendFight3v3* fight3v3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight3v3_);
  }
  if (fight3v3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight3v3));
    if (message_arena != submessage_arena) {
      fight3v3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fight3v3, submessage_arena);
    }
    
  } else {
    
  }
  fight3v3_ = fight3v3;
  // @@protoc_insertion_point(field_set_allocated:common.MatchFighterExtend.fight3v3)
}

// .common.ExtendFight5v5 fight5v5 = 2;
inline bool MatchFighterExtend::_internal_has_fight5v5() const {
  return this != internal_default_instance() && fight5v5_ != nullptr;
}
inline bool MatchFighterExtend::has_fight5v5() const {
  return _internal_has_fight5v5();
}
inline const ::common::ExtendFight5v5& MatchFighterExtend::_internal_fight5v5() const {
  const ::common::ExtendFight5v5* p = fight5v5_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::ExtendFight5v5&>(
      ::common::_ExtendFight5v5_default_instance_);
}
inline const ::common::ExtendFight5v5& MatchFighterExtend::fight5v5() const {
  // @@protoc_insertion_point(field_get:common.MatchFighterExtend.fight5v5)
  return _internal_fight5v5();
}
inline void MatchFighterExtend::unsafe_arena_set_allocated_fight5v5(
    ::common::ExtendFight5v5* fight5v5) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight5v5_);
  }
  fight5v5_ = fight5v5;
  if (fight5v5) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.MatchFighterExtend.fight5v5)
}
inline ::common::ExtendFight5v5* MatchFighterExtend::release_fight5v5() {
  
  ::common::ExtendFight5v5* temp = fight5v5_;
  fight5v5_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::ExtendFight5v5* MatchFighterExtend::unsafe_arena_release_fight5v5() {
  // @@protoc_insertion_point(field_release:common.MatchFighterExtend.fight5v5)
  
  ::common::ExtendFight5v5* temp = fight5v5_;
  fight5v5_ = nullptr;
  return temp;
}
inline ::common::ExtendFight5v5* MatchFighterExtend::_internal_mutable_fight5v5() {
  
  if (fight5v5_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::ExtendFight5v5>(GetArenaForAllocation());
    fight5v5_ = p;
  }
  return fight5v5_;
}
inline ::common::ExtendFight5v5* MatchFighterExtend::mutable_fight5v5() {
  ::common::ExtendFight5v5* _msg = _internal_mutable_fight5v5();
  // @@protoc_insertion_point(field_mutable:common.MatchFighterExtend.fight5v5)
  return _msg;
}
inline void MatchFighterExtend::set_allocated_fight5v5(::common::ExtendFight5v5* fight5v5) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight5v5_);
  }
  if (fight5v5) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fight5v5));
    if (message_arena != submessage_arena) {
      fight5v5 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fight5v5, submessage_arena);
    }
    
  } else {
    
  }
  fight5v5_ = fight5v5;
  // @@protoc_insertion_point(field_set_allocated:common.MatchFighterExtend.fight5v5)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::common::enStageId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::enStageId>() {
  return ::common::enStageId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_matchcommon_2eproto
