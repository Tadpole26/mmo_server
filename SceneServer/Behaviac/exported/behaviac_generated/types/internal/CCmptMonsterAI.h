// -------------------------------------------------------------------------------
// THIS FILE IS ORIGINALLY GENERATED BY THE DESIGNER.
// YOU ARE ONLY ALLOWED TO MODIFY CODE BETWEEN '///<<< BEGIN' AND '///<<< END'.
// PLEASE MODIFY AND REGENERETE IT IN THE DESIGNER FOR CLASS/MEMBERS/METHODS, ETC.
// -------------------------------------------------------------------------------

#ifndef _BEHAVIAC_CCMPTMONSTERAI_H_
#define _BEHAVIAC_CCMPTMONSTERAI_H_

#include "behaviac_headers.h"

///<<< BEGIN WRITING YOUR CODE FILE_INIT
#include "sdk.h"
#include "CHatredHandle.h"
class CNpcMonster;
class CCmptView;
class CHatredHandle;
///<<< END WRITING YOUR CODE

class CCmptMonsterAI : public behaviac::Agent
///<<< BEGIN WRITING YOUR CODE CCmptMonsterAI
///<<< END WRITING YOUR CODE
{
public:
	CCmptMonsterAI();
	virtual ~CCmptMonsterAI();

	BEHAVIAC_DECLARE_AGENTTYPE(CCmptMonsterAI, behaviac::Agent)

	public: AIState m_eCurState;

	public: unsigned long long m_ullRestExpire;

///<<< BEGIN WRITING YOUR CODE CLASS_PART
	using StateHandle = bool (CCmptMonsterAI::*)();
	static std::vector<StateHandle> kStateHandles;
	using Entity = CHatredHandle::Entity;
public:
	//void SwitchState(AIState uiState);
	//bool StateLoop();
	//bool StateIdle();										
	//bool StateSelectSkill();
	//bool StateCastSkill();
	//bool StateChase();
	//bool StateChaseWait();
	//bool StateBackHome();
	//bool StateBackHomeWait(); 
	//bool StatePatrol();
	//bool StatePatrolWait();
	//bool StateRest();
public:
	bool Init(CNpcMonster* pNpcMonster);
	void Final();
	CNpcMonster* NpcMonsterPtr() { return m_pNpcMonster; }
	CNpcMonster& NpcMonsterRef() { return *m_pNpcMonster; }
	//CCmptView* ViewCmptPtr() { return NpcMonsterRef().ViewCmptPtr(); }
	//CCmptView& ViewCmptRef() { return NpcMonsterRef().ViewCmptRef(); }
	CHatredHandle& HatredRef() { return *m_pHatred; }
	CCmptView* GetViewByEntity(const Entity& oEntity);
public:
	//仇恨
	//CCmptView* GetFightTarget();
	//CCmptView* GetRandomFightTarget();
	//CCmptView* ScanFightTarget();
	//void SetFightTarget(CCmptView& oTarget);
	//void RemoveFightTarget(CCmptView& oTarget);
	//void ClearAllFightTarget();
	//bool IsHatredOpen();
	//bool HasHatred() { return false; }
	//void AddHatred(CCmptView& oTarget, uint32 uiValue) {}
	//void SubHatred(CCmptView& oTarget, uint32 uiValue) {}
	//void AddHatredPer(CCmptView& oTarget, uint32 uiPer) {}
	//void SubHatredPer(CCmptView& oTarget, uint32 uiPer) {}
	//void AddHatedBy(CCmptView& oFrom) {}
	//void RemoveHatedBy(CCmptView& oFrom) {}
	//bool foreachHatedBy(std::function<bool(CCmptView&)> func) { return true; }
	//巡逻
	//zPos RandomPatrolPos();
	zPos GetHomePos() { return {}; }
	//uint32 GetHomeRange() { return MAX_SCREEN_GRID; }
	void OnBackHome() {}
	void OnReachHome() {}
	bool HomeWaiting() { return true; }
	//bool CanPatrol();
	bool FarAwayFromHome(const zPos& oPos) { return true; }
	uint32 PatrolInterval() { return 1000; }
	uint64 GetPatrolExpire() { return 0; }
	void SetPatrolExpire(uint64 ullExpire) {}
	void OnEnterChase() {}
	//void MoveToPos(const zPos& oPos);
	//技能
	//void SetNextSkillTarget(uint32 uiType, uint64 ullUid);
	//void SetNextSkillPos(const zPos& oPos);
	//CCmptView* GetNextSkillTarget();
	//uint32 GetNextSkill();
	//void SetNextSkill(uint32 uiSkillId);
	//uint32 SelectSkill();
	//void CastSkill();
	//void ClearSkill();
	//uint32 GetActiveAttachRange();
	//bool CheckCastSkillCD();
	uint32 GetSkillByOrder(uint32 uiOrder) { return 0; }
	//bool CanActiveAttack();
	//uint32 GetCastSkillRange(uint32 uiSkillId);
	//uint32 GetAttachRange();
	//无状态(rest)
	//bool CanRest();
	//说话
	void Speak(uint32 uiType, uint32 uiTid) {}
	void AddCountDown(uint32 uiId, uint32 uiLasting, uint32 uiDelay) {}
	uint32 GetCountDown(uint32 uiId) { return 0; }
private:
	CNpcMonster* m_pNpcMonster;
	CHatredHandle* m_pHatred;
///<<< END WRITING YOUR CODE
};

///<<< BEGIN WRITING YOUR CODE FILE_UNINIT

///<<< END WRITING YOUR CODE

#endif
