// -------------------------------------------------------------------------------
// THIS FILE IS ORIGINALLY GENERATED BY THE DESIGNER.
// YOU ARE ONLY ALLOWED TO MODIFY CODE BETWEEN '///<<< BEGIN' AND '///<<< END'.
// PLEASE MODIFY AND REGENERETE IT IN THE DESIGNER FOR CLASS/MEMBERS/METHODS, ETC.
// -------------------------------------------------------------------------------

#include "CCmptMonsterAI.h"

///<<< BEGIN WRITING YOUR CODE FILE_INIT
#include "CNpcMonster.h"
#include "CCmptNpcMonsterView.h"
///<<< END WRITING YOUR CODE

CCmptMonsterAI::CCmptMonsterAI()
{
	m_eCurState = AIState_Idle;
	m_ullRestExpire = 0;
///<<< BEGIN WRITING YOUR CODE CONSTRUCTOR
	m_pNpcMonster = nullptr;
///<<< END WRITING YOUR CODE
}

CCmptMonsterAI::~CCmptMonsterAI()
{
///<<< BEGIN WRITING YOUR CODE DESTRUCTOR

///<<< END WRITING YOUR CODE
}


///<<< BEGIN WRITING YOUR CODE FILE_UNINIT
bool CCmptMonsterAI::Init(CNpcMonster* pNpcMonster)
{
	assert(pNpcMonster);
	m_pNpcMonster = pNpcMonster;
	m_pHatred = NpcMonsterRef().IsBoss() ? static_cast<CHatredHandle*>(new CHatredHandleMap()) : new CHatredHandleArr();
	m_pHatred->Init();
	return true;
}

void CCmptMonsterAI::Final()
{
	if (m_pHatred)
	{
		m_pHatred->Final();
		SAFE_DELETE(m_pHatred);
	}
}

CCmptView* CCmptMonsterAI::GetViewByEntity(const Entity& oEntity)
{
	//地图动态npc
	if (oEntity.uiType == 1)
	{
		return nullptr;
	}
	return nullptr;
}

std::vector<CCmptMonsterAI::StateHandle> CCmptMonsterAI::kStateHandles
{
	//& CCmptMonsterAI::StateIdle,
	//& CCmptMonsterAI::StateSelectSkill,
	//& CCmptMonsterAI::StateCastSkill,
	//& CCmptMonsterAI::StateChase,
	//& CCmptMonsterAI::StateChaseWait,
	//& CCmptMonsterAI::StateBackHome,
	//& CCmptMonsterAI::StateBackHomeWait,
	//& CCmptMonsterAI::StatePatrol,								
	//& CCmptMonsterAI::StatePatrolWait,
	//& CCmptMonsterAI::StateRest,
};


///<<< END WRITING YOUR CODE
